/*
 * Parkinson's Disease Movement Detector
 * Phases 1-5: Complete System with BLE
 * 
 * Board: STM32 DISCO-L475VG-IOT01A
 * Sensor: LSM6DSL (Accelerometer + Gyroscope)
 * 
 * Features:
 * - Phase 1: 52Hz interrupt-driven data acquisition
 * - Phase 2: 3-second windowed data collection
 * - Phase 3: FFT-based tremor & dyskinesia detection
 * - Phase 4: FOG (Freezing of Gait) detection
 * - Phase 5: BLE transmission to mobile device
 * 
 * Detection:
 * - Tremor: 3-5 Hz rhythmic oscillations
 * - Dyskinesia: 5-7 Hz dance-like movements
 * - FOG: Walking ‚Üí sudden freeze pattern
 */

#include "mbed.h"
#include "arm_math.h"  // CMSIS-DSP library for FFT

// BLE includes
#include "ble/BLE.h"
#include "ble/Gap.h"
#include "ble/GattServer.h"
#include "ble/GattCharacteristic.h"
#include "ble/GattService.h"
#include "ble/gap/AdvertisingDataBuilder.h"
#include "events/EventQueue.h"

    // =============================================================================
    // Hardware Configuration
    // =============================================================================

    // I2C pins for LSM6DSL on DISCO-L475VG-IOT01A
    I2C i2c(PB_11, PB_10);  // SDA, SCL

    // Interrupt pin for data-ready signal
    InterruptIn data_ready_pin(PD_11, PullDown);

    // LED for visual feedback
    DigitalOut led(LED1);

    // Serial console
BufferedSerial serial_port(USBTX, USBRX, 115200);
FileHandle *mbed::mbed_override_console(int) {
    return &serial_port;
}

    // =============================================================================
    // LSM6DSL Register Definitions
    // =============================================================================

    #define LSM6DSL_ADDR        (0x6A << 1)  // I2C address (7-bit shifted)

    // Register addresses
    #define WHO_AM_I            0x0F
    #define CTRL1_XL            0x10  // Accelerometer control
    #define CTRL2_G             0x11  // Gyroscope control
    #define CTRL3_C             0x12  // Common control
    #define INT1_CTRL           0x0D  // INT1 pin control
    #define STATUS_REG          0x1E  // Status register
    #define OUTX_L_XL           0x28  // Accelerometer data start
    #define OUTX_L_G            0x22  // Gyroscope data start

    // Expected WHO_AM_I value for LSM6DSL
    #define LSM6DSL_WHO_AM_I_VAL  0x6A

    // =============================================================================
    // Sampling Configuration
    // =============================================================================

    const float TARGET_SAMPLE_RATE_HZ = 52.0f;
    const float EXPECTED_SAMPLE_PERIOD_MS = 1000.0f / TARGET_SAMPLE_RATE_HZ;  // ~19.23ms

    // Window configuration for FFT analysis
    const size_t WINDOW_SIZE = 156;  // 3 seconds * 52 Hz = 156 samples
    const size_t FFT_SIZE = 256;     // Zero-pad to power of 2 for efficient FFT

    // =============================================================================
    // Global Variables
    // =============================================================================

    volatile bool new_data_available = false;
    volatile uint32_t interrupt_count = 0;  // Count ISR calls
    uint32_t sample_count = 0;
    uint32_t last_sample_time_ms = 0;

    // =============================================================================
    // Data Buffers for Window Collection
    // =============================================================================

    float accel_magnitude_buffer[WINDOW_SIZE];  // Circular buffer for accel magnitude
    float gyro_magnitude_buffer[WINDOW_SIZE];   // Circular buffer for gyro magnitude  
    size_t buffer_index = 0;                     // Current position in buffer
    volatile bool window_ready = false;          // Flag when 156 samples collected
    uint32_t window_count = 0;                   // Number of windows processed

    // =============================================================================
    // FOG Detection - Step Tracking & State Machine
    // =============================================================================

    // Step detection parameters (relaxed for easier detection)
    const float STEP_THRESHOLD = 0.10f;          // Magnitude deviation from baseline (g) - LOWERED
    const uint32_t MIN_STEP_INTERVAL_MS = 150;   // Minimum 150ms between steps (max 400 steps/min)

    // Step tracking
    uint16_t steps_in_window = 0;                // Steps detected in current window
    bool above_step_threshold = false;           // For peak detection
    uint32_t last_step_time_ms = 0;              // Timestamp of last step

    // FOG state machine
    enum FOGState {
        FOG_NOT_WALKING,
        FOG_WALKING,
        FOG_POTENTIAL_FREEZE,
        FOG_FREEZE_CONFIRMED
    };

struct FOGDetector {
    FOGState state;
    uint32_t walking_start_time;
    uint32_t freeze_start_time;
    float previous_cadence;
    uint8_t consecutive_walking_windows;
    uint8_t consecutive_freeze_windows;
} fog_detector = {FOG_NOT_WALKING, 0, 0, 0.0f, 0, 0};

// =============================================================================
// BLE - Detection Results Storage & Service
// =============================================================================

// Current detection results (updated after each window)
// Three separate characteristics for three conditions (as per spec)
static uint16_t tremor_intensity = 0;           // 0-1000 scale (0 = none)
static uint16_t dysk_intensity = 0;             // 0-1000 scale (0 = none)
static uint16_t fog_status = 0;                 // 0 = NOFOG, 1 = FOG (or 0-1000 scale)
static bool ble_connected = false;

// Previous values for change detection (to send notifications)
static uint16_t previous_tremor = 0;
static uint16_t previous_dysk = 0;
static uint16_t previous_fog = 0;

// Multi-window confirmation tracking
struct DetectionConfirmation {
    char last_raw_detection[16];    // Last raw detection from FFT
    uint8_t tremor_consecutive;      // Consecutive tremor detections
    uint8_t dysk_consecutive;        // Consecutive dyskinesia detections
    uint8_t none_consecutive;        // Consecutive "NONE" detections
    float tremor_ema_intensity;      // EMA smoothed intensity for tremor
    float dysk_ema_intensity;        // EMA smoothed intensity for dyskinesia
} detection_state = {"NONE", 0, 0, 0, 0.0f, 0.0f};

const uint8_t DETECTION_CONFIRM_WINDOWS = 2;  // Need 2 consecutive windows (~6 sec)
const uint8_t CLEAR_CONFIRM_WINDOWS = 3;      // Need 3 consecutive windows (~9 sec)
const float EMA_ALPHA = 0.3f;                 // EMA smoothing factor (0-1, higher = faster response)

// BLE objects
using namespace ble;
events::EventQueue ble_event_queue(16 * EVENTS_EVENT_SIZE);
BLE &ble_instance = BLE::Instance();

// UUIDs for service and characteristics
// Three characteristics for three conditions (Tremor, Dyskinesia, FOG)
const UUID PD_SERVICE_UUID("A0E1B2C3-D4E5-F6A7-B8C9-D0E1F2A3B4C5");
const UUID TREMOR_CHAR_UUID("A1E2B3C4-D5E6-F7A8-B9C0-D1E2F3A4B5C6");
const UUID DYSK_CHAR_UUID("A2E3B4C5-D6E7-F8A9-B0C1-D2E3F4A5B6C7");
const UUID FOG_CHAR_UUID("A3E4B5C6-D7E8-F9AA-B1C2-D3E4F5A6B7C8");

// GattCharacteristic pointers (will be created after BLE init)
GattCharacteristic *tremor_char = nullptr;
GattCharacteristic *dysk_char = nullptr;
GattCharacteristic *fog_char = nullptr;
GattServer *gatt_server = nullptr;

// Forward declaration
void update_ble_characteristics();

    // =============================================================================
    // I2C Helper Functions
    // =============================================================================

    /**
    * Write a single byte to a register
    */
    bool write_register(uint8_t reg, uint8_t value) {
        char data[2] = {(char)reg, (char)value};
        int result = i2c.write(LSM6DSL_ADDR, data, 2);
        return (result == 0);  // 0 = success
    }

    /**
    * Read a single byte from a register
    */
    bool read_register(uint8_t reg, uint8_t &value) {
        char reg_addr = (char)reg;
        
        // Write register address
        if (i2c.write(LSM6DSL_ADDR, &reg_addr, 1, true) != 0) {
            return false;
        }
        
        // Read data
        char data;
        if (i2c.read(LSM6DSL_ADDR, &data, 1) != 0) {
            return false;
        }
        
        value = (uint8_t)data;
    return true;
}

    /**
    * Read multiple bytes in a burst (auto-increment enabled)
    */
    bool read_burst(uint8_t start_reg, uint8_t *buffer, uint8_t length) {
        char reg_addr = (char)start_reg;
        
        // Write register address
        if (i2c.write(LSM6DSL_ADDR, &reg_addr, 1, true) != 0) {
            return false;
        }
        
        // Read data
        if (i2c.read(LSM6DSL_ADDR, (char*)buffer, length) != 0) {
            return false;
        }
        
        return true;
    }

    /**
    * Read a 16-bit value (low byte first, then high byte)
    */
    bool read_int16(uint8_t reg_low, int16_t &value) {
        uint8_t low_byte, high_byte;
        
        if (!read_register(reg_low, low_byte)) return false;
        if (!read_register(reg_low + 1, high_byte)) return false;
        
        value = (int16_t)((high_byte << 8) | low_byte);
    return true;
}

    // =============================================================================
    // LSM6DSL Initialization
    // =============================================================================

    bool init_lsm6dsl() {
        printf("\n=== Initializing LSM6DSL Sensor ===\n");
        
        // Step 1: Check WHO_AM_I register
        printf("1. Checking WHO_AM_I register...\n");
        uint8_t who_am_i = 0;
        if (!read_register(WHO_AM_I, who_am_i)) {
            printf("   ‚ùå ERROR: Cannot read WHO_AM_I register\n");
        return false;
    }

        printf("   WHO_AM_I = 0x%02X (expected 0x%02X)\n", who_am_i, LSM6DSL_WHO_AM_I_VAL);
        
        if (who_am_i != LSM6DSL_WHO_AM_I_VAL) {
            printf("   ‚ùå ERROR: Wrong device ID\n");
            return false;
        }
        printf("   ‚úì Correct device detected\n\n");
        
        // Step 2: Configure CTRL3_C (Common settings)
        printf("2. Configuring common settings (CTRL3_C)...\n");
        // BDU=1 (Block Data Update), IF_INC=1 (Auto-increment address)
        if (!write_register(CTRL3_C, 0x44)) {
            printf("   ‚ùå ERROR: Cannot write CTRL3_C\n");
            return false;
        }
        printf("   ‚úì BDU and auto-increment enabled\n\n");
        
        // Step 3: Configure Accelerometer (CTRL1_XL)
        printf("3. Configuring accelerometer (CTRL1_XL)...\n");
        // ODR = 52Hz (0011b), FS = ¬±2g (00b), BW = 400Hz (00b)
        // Register value: 0011 00 00 = 0x30
        if (!write_register(CTRL1_XL, 0x30)) {
            printf("   ‚ùå ERROR: Cannot write CTRL1_XL\n");
            return false;
        }
        printf("   ‚úì Accelerometer: 52Hz, ¬±2g\n\n");
        
        // Step 4: Configure Gyroscope (CTRL2_G)
        printf("4. Configuring gyroscope (CTRL2_G)...\n");
        // ODR = 52Hz (0011b), FS = ¬±250dps (00b)
        // Register value: 0011 00 00 = 0x30
        if (!write_register(CTRL2_G, 0x30)) {
            printf("   ‚ùå ERROR: Cannot write CTRL2_G\n");
            return false;
        }
        printf("   ‚úì Gyroscope: 52Hz, ¬±250dps\n\n");
        
        // Step 5: Configure INT1 pin for data-ready
        printf("5. Configuring INT1 pin (INT1_CTRL)...\n");
        // INT1_DRDY_XL=1 (bit 0), INT1_DRDY_G=1 (bit 1)
        // Register value: 0000 0011 = 0x03
        if (!write_register(INT1_CTRL, 0x03)) {
            printf("   ‚ùå ERROR: Cannot write INT1_CTRL\n");
            return false;
        }
        printf("   ‚úì INT1 configured for accel+gyro data-ready\n\n");
        
        // Step 6: Clear any pending data by reading STATUS_REG
    uint8_t dummy;
        read_register(STATUS_REG, dummy);

        printf("=== LSM6DSL Initialization Complete ===\n\n");
    return true;
}

    // =============================================================================
    // Interrupt Service Routine
    // =============================================================================

    /**
    * ISR: Called when INT1 pin goes high (data ready)
    * Keep this minimal - just set a flag
    */
void data_ready_isr() {
        new_data_available = true;
        interrupt_count++;
    }

    // =============================================================================
    // Data Reading Function
    // =============================================================================

    /**
    * Read and process one sample from the sensor
    */
    void read_sensor_data() {
        // Read raw accelerometer data (6 bytes: X,Y,Z as 16-bit each) - BURST READ
        uint8_t accel_data[6];
        if (!read_burst(OUTX_L_XL, accel_data, 6)) return;
        
        int16_t accel_x_raw = (int16_t)((accel_data[1] << 8) | accel_data[0]);  // X: [1][0]
        int16_t accel_y_raw = (int16_t)((accel_data[3] << 8) | accel_data[2]);  // Y: [3][2]
        int16_t accel_z_raw = (int16_t)((accel_data[5] << 8) | accel_data[4]);  // Z: [5][4]
        
        // Read raw gyroscope data (6 bytes: X,Y,Z as 16-bit each) - BURST READ
        uint8_t gyro_data[6];
        if (!read_burst(OUTX_L_G, gyro_data, 6)) return;
        
        int16_t gyro_x_raw = (int16_t)((gyro_data[1] << 8) | gyro_data[0]);  // X: [1][0]
        int16_t gyro_y_raw = (int16_t)((gyro_data[3] << 8) | gyro_data[2]);  // Y: [3][2]
        int16_t gyro_z_raw = (int16_t)((gyro_data[5] << 8) | gyro_data[4]);  // Z: [5][4]
        
        // Convert to physical units
        // Accelerometer: ¬±2g range, 16-bit resolution
        // Sensitivity = 2g / 32768 = 0.000061g per LSB, but datasheet says 0.061 mg/LSB
        const float ACCEL_SCALE = 0.000061f;  // g per LSB
        float accel_x = accel_x_raw * ACCEL_SCALE;
        float accel_y = accel_y_raw * ACCEL_SCALE;
        float accel_z = accel_z_raw * ACCEL_SCALE;
        
        // Gyroscope: ¬±250dps range, 16-bit resolution  
        // Sensitivity = 8.75 mdps/LSB (from datasheet)
        const float GYRO_SCALE = 0.00875f;  // dps per LSB
        float gyro_x = gyro_x_raw * GYRO_SCALE;
        float gyro_y = gyro_y_raw * GYRO_SCALE;
        float gyro_z = gyro_z_raw * GYRO_SCALE;
        
        // Calculate magnitudes (what we'll use for tremor/dyskinesia detection)
        float accel_magnitude = sqrtf(accel_x*accel_x + accel_y*accel_y + accel_z*accel_z);
        float gyro_magnitude = sqrtf(gyro_x*gyro_x + gyro_y*gyro_y + gyro_z*gyro_z);
        
        // Calculate actual sampling rate
        uint32_t current_time = Kernel::get_ms_count();
        float actual_period_ms = 0.0f;
        float actual_rate_hz = 0.0f;
        
        if (sample_count > 0) {
            actual_period_ms = current_time - last_sample_time_ms;
            actual_rate_hz = 1000.0f / actual_period_ms;
        }
        last_sample_time_ms = current_time;
        
        sample_count++;
        
        // =========================================================================
        // PHASE 2: Store accelerometer and gyroscope magnitudes in circular buffers
        // =========================================================================
        accel_magnitude_buffer[buffer_index] = accel_magnitude;
        gyro_magnitude_buffer[buffer_index] = gyro_magnitude;
        buffer_index++;
        
        // Check if we've collected a full 3-second window
        if (buffer_index >= WINDOW_SIZE) {
            buffer_index = 0;  // Wrap around (circular buffer)
            window_ready = true;  // Signal that window is ready for processing
        }
        
        // =========================================================================
        // PHASE 4: Step Detection for FOG Analysis
        // =========================================================================
        // Detect steps using deviation from baseline (1g when still)
        float deviation = fabsf(accel_magnitude - 1.0f);
    uint32_t now = Kernel::get_ms_count();

        // Peak detection: rising edge above threshold
        if (deviation > STEP_THRESHOLD && !above_step_threshold) {
            // Check minimum time between steps (avoid double-counting)
            if (now - last_step_time_ms > MIN_STEP_INTERVAL_MS) {
                steps_in_window++;
                last_step_time_ms = now;
            }
            above_step_threshold = true;
        } 
        // Falling edge below threshold (reset for next peak)
        else if (deviation < STEP_THRESHOLD * 0.5f) {
            above_step_threshold = false;
        }
        
    // Compact status update (every 52 samples = ~1 second) - DISABLED for cleaner output
    // Uncomment next 2 lines if you want per-second updates:
    // if (sample_count % 52 == 0) {
    //     printf("[%lu s] %.1fHz | %.3fg\n", current_time/1000, actual_rate_hz, accel_magnitude);
    // }
    
    // Toggle LED to show activity
    if (sample_count % 52 == 0) {
        led = !led;
    }
        
        // Minimal Teleplot data (only key metrics for visualization)
        // Uncomment if you want to use Teleplot or similar graphing tools:
        // printf(">accel_mag:%.3f\n", accel_magnitude);
        // printf(">buffer_progress:%zu\n", buffer_index);
    }

    // =============================================================================
    // FFT Analysis & Detection Functions (Phase 3)
    // =============================================================================

    /**
    * Perform FFT analysis and detect tremor/dyskinesia
    * Returns raw detection (before multi-window confirmation)
    * Uses both accelerometer and gyroscope data for robustness
    * 
    * @param accel_data - Array of accelerometer magnitude samples
    * @param gyro_data - Array of gyroscope magnitude samples
    * @param size - Number of samples (should be WINDOW_SIZE = 156)
    * @param sample_rate - Sampling frequency in Hz
    * @param[out] raw_condition - Raw detection result ("NONE", "TREMOR", "DYSK")
    * @param[out] raw_intensity - Raw intensity value
    */
    void analyze_frequency_content(float* accel_data, float* gyro_data, size_t size, float sample_rate, 
                                   char* raw_condition, float* raw_intensity) {
        // Initialize output parameters (in case of early return)
        strcpy(raw_condition, "NONE");
        *raw_intensity = 0.0f;
        
        // Step 1: Combine accelerometer and gyroscope data with proper normalization
        // Accel captures translational movement, gyro captures rotational
        // Normalize each by its own standard deviation to balance contributions
        static float combined_data[WINDOW_SIZE];
        
        // Calculate means for DC removal
        float accel_sum = 0.0f, gyro_sum = 0.0f;
        for (size_t i = 0; i < size; i++) {
            accel_sum += accel_data[i];
            gyro_sum += gyro_data[i];
        }
        float accel_mean = accel_sum / size;
        float gyro_mean = gyro_sum / size;
        
        // Remove DC and calculate standard deviations
        static float accel_norm[WINDOW_SIZE], gyro_norm[WINDOW_SIZE];
        float accel_var = 0.0f, gyro_var = 0.0f;
        
        for (size_t i = 0; i < size; i++) {
            accel_norm[i] = accel_data[i] - accel_mean;
            gyro_norm[i] = gyro_data[i] - gyro_mean;
            accel_var += accel_norm[i] * accel_norm[i];
            gyro_var += gyro_norm[i] * gyro_norm[i];
        }
        
        float accel_std = sqrtf(accel_var / size);
        float gyro_std = sqrtf(gyro_var / size);
        const float eps = 1e-6f;  // Small epsilon to avoid division by zero
        
        // Normalize by standard deviation and combine
        // Weight: 70% accel, 30% gyro for PD movement patterns
        for (size_t i = 0; i < size; i++) {
            float accel_z = accel_norm[i] / (accel_std + eps);
            float gyro_z = gyro_norm[i] / (gyro_std + eps);
            combined_data[i] = 0.7f * accel_z + 0.3f * gyro_z;
        }
        
        // Step 2: Apply Hann window to reduce spectral leakage
        // Hann window: w(n) = 0.5 * (1 - cos(2œÄ*n / (N-1)))
        static float windowed_data[WINDOW_SIZE];
        const float pi = 3.14159265359f;
        
        for (size_t i = 0; i < size; i++) {
            float hann_coeff = 0.5f * (1.0f - cosf(2.0f * pi * i / (size - 1)));
            windowed_data[i] = combined_data[i] * hann_coeff;
        }
        
        // Step 3: Prepare FFT input buffer (zero-padded to FFT_SIZE = 256)
        static float fft_input[FFT_SIZE];
        for (size_t i = 0; i < FFT_SIZE; i++) {
            if (i < size) {
                fft_input[i] = windowed_data[i];  // Use windowed data
            } else {
                fft_input[i] = 0.0f;  // Zero-padding
            }
        }
        
        // Step 4: Initialize FFT instance
        arm_rfft_fast_instance_f32 fft_instance;
        arm_status status = arm_rfft_fast_init_f32(&fft_instance, FFT_SIZE);
        
        if (status != ARM_MATH_SUCCESS) {
            printf("‚ùå FFT initialization failed!\n");
            // Output parameters already initialized to safe defaults
            return;
        }
        
        // Step 5: Perform FFT
        static float fft_output[FFT_SIZE];
        arm_rfft_fast_f32(&fft_instance, fft_input, fft_output, 0);
        
        // Step 6: Calculate magnitude spectrum with correct CMSIS RFFT bin indexing
        // CMSIS RFFT output format: [DC, R1, I1, R2, I2, ..., R(N/2-1), I(N/2-1), Nyquist]
        // DC and Nyquist are real-only, others are complex pairs
        
        const size_t num_bins = FFT_SIZE / 2 + 1;  // 129 bins (0 to Nyquist)
        const float freq_resolution = sample_rate / FFT_SIZE;  // Hz per bin (~0.203 Hz)
        
        float dominant_freq = 0.0f;
        float dominant_magnitude = 0.0f;
        
        float tremor_peak = 0.0f;      // Peak in 3-5 Hz band
        float tremor_freq = 0.0f;
        float dyskinesia_peak = 0.0f;  // Peak in 5-7 Hz band
        float dyskinesia_freq = 0.0f;
        
        // Analyze frequency bins with correct indexing
        for (size_t k = 1; k < num_bins - 1; k++) {  // Skip DC (k=0) and Nyquist (k=N/2)
            float real = fft_output[2 * k];      // Real part at index 2k
            float imag = fft_output[2 * k + 1];  // Imaginary part at index 2k+1
            float magnitude = sqrtf(real * real + imag * imag);
            float frequency = k * freq_resolution;
            
            // Track overall dominant frequency
            if (magnitude > dominant_magnitude) {
                dominant_magnitude = magnitude;
                dominant_freq = frequency;
            }
            
            // Check tremor band (3-5 Hz)
            if (frequency >= 3.0f && frequency <= 5.0f) {
                if (magnitude > tremor_peak) {
                    tremor_peak = magnitude;
                    tremor_freq = frequency;
                }
            }
            
            // Check dyskinesia band (5-7 Hz)
            if (frequency >= 5.0f && frequency <= 7.0f) {
                if (magnitude > dyskinesia_peak) {
                    dyskinesia_peak = magnitude;
                    dyskinesia_freq = frequency;
                }
            }
        }
        
        // Step 7: Improved Detection Logic with Adjusted Thresholds
        const float TREMOR_THRESHOLD = 1.0f;        // Tremor detection threshold
        const float DYSK_THRESHOLD = 1.2f;          // Dyskinesia threshold (harder to trigger)
        const float INTENSITY_SCALE = 2.0f;         // Scale factor for intensity display
        const float DOMINANCE_RATIO = 1.3f;         // Peak must be 1.3x stronger than other band
        
        const char* condition = "NONE";
        float intensity = 0.0f;
        
        // More selective detection criteria:
        // 1. Peak must exceed specific threshold (tremor=1.0, dysk=1.2)
        // 2. Dominant frequency must be in the target band
        // 3. Peak must be clearly stronger than the other band (1.3x ratio)
        
        bool tremor_detected = (tremor_peak > TREMOR_THRESHOLD) && 
                            (dominant_freq >= 3.0f && dominant_freq <= 5.0f) &&
                            (tremor_peak > dyskinesia_peak * DOMINANCE_RATIO);  // Tremor peak is dominant
        
        bool dysk_detected = (dyskinesia_peak > DYSK_THRESHOLD) && 
                            (dominant_freq >= 5.0f && dominant_freq <= 7.0f) &&
                            (dyskinesia_peak > tremor_peak * DOMINANCE_RATIO);  // Dyskinesia peak is dominant
        
        // Determine primary condition
        if (tremor_detected) {
            condition = "TREMOR";
            intensity = tremor_peak * INTENSITY_SCALE;
        } else if (dysk_detected) {
            condition = "DYSK";
            intensity = dyskinesia_peak * INTENSITY_SCALE;
        }
        
        // Return raw detection via output parameters
        strncpy(raw_condition, condition, 15);
        raw_condition[15] = '\0';
        *raw_intensity = intensity;
        
        // Display raw detection result
        if (strcmp(condition, "TREMOR") == 0) {
            printf("Raw: üî¥ TREMOR | Intensity: %.1f | Freq: %.1f Hz ", intensity, dominant_freq);
        } else if (strcmp(condition, "DYSK") == 0) {
            printf("Raw: üü† DYSK | Intensity: %.1f | Freq: %.1f Hz ", intensity, dominant_freq);
        } else {
            printf("Raw: ‚úÖ Normal ");
        }
    }

    /**
    * Process a complete 3-second window of data
    * This will be called when buffer_index wraps (156 samples collected)
    */
    void process_window() {
        window_ready = false;  // Clear flag
        window_count++;

    printf("\n>>> Window #%-4u | ", window_count);
    
    // Calculate statistics on the raw data
    float sum = 0.0f;
    for (size_t i = 0; i < WINDOW_SIZE; i++) {
        sum += accel_magnitude_buffer[i];
    }
    float mean = sum / WINDOW_SIZE;
    
    // Calculate variance (measure of movement)
    float variance = 0.0f;
    for (size_t i = 0; i < WINDOW_SIZE; i++) {
        float diff = accel_magnitude_buffer[i] - mean;
        variance += diff * diff;
    }
    variance /= WINDOW_SIZE;
    float std_dev = sqrtf(variance);
        
    // PHASE 3: Perform FFT analysis and detection (only if there's enough movement)
    char raw_detection[16] = "NONE";
    float raw_intensity = 0.0f;
    
    if (std_dev >= 0.05f) {
        analyze_frequency_content(accel_magnitude_buffer, gyro_magnitude_buffer, WINDOW_SIZE, TARGET_SAMPLE_RATE_HZ, 
                                  raw_detection, &raw_intensity);
    } else {
        printf("Raw: ‚úÖ Normal (still) ");
        strcpy(raw_detection, "NONE");
        raw_intensity = 0.0f;
    }
    
    // Multi-window confirmation logic
    // Track consecutive detections for confirmation
    if (strcmp(raw_detection, "TREMOR") == 0) {
        detection_state.tremor_consecutive++;
        detection_state.dysk_consecutive = 0;
        detection_state.none_consecutive = 0;
        
        // Apply EMA smoothing to tremor intensity
        detection_state.tremor_ema_intensity = EMA_ALPHA * raw_intensity + 
                                             (1.0f - EMA_ALPHA) * detection_state.tremor_ema_intensity;
    } else if (strcmp(raw_detection, "DYSK") == 0) {
        detection_state.dysk_consecutive++;
        detection_state.tremor_consecutive = 0;
        detection_state.none_consecutive = 0;
        
        // Apply EMA smoothing to dyskinesia intensity
        detection_state.dysk_ema_intensity = EMA_ALPHA * raw_intensity + 
                                           (1.0f - EMA_ALPHA) * detection_state.dysk_ema_intensity;
    } else {  // "NONE"
        detection_state.none_consecutive++;
        detection_state.tremor_consecutive = 0;
        detection_state.dysk_consecutive = 0;
        // Keep EMA values but don't update them during "NONE" periods
    }
    
    // Determine confirmed intensities based on consecutive windows
    // Each condition gets its own intensity value (0 = not present)
    
    // Confirm tremor if detected in 2 consecutive windows (~6 sec)
    if (detection_state.tremor_consecutive >= DETECTION_CONFIRM_WINDOWS) {
        tremor_intensity = (uint16_t)(detection_state.tremor_ema_intensity * 500.0f);  // Scale to 0-1000
        if (tremor_intensity > 1000) tremor_intensity = 1000;
        dysk_intensity = 0;  // Clear other condition
    }
    // Confirm dyskinesia if detected in 2 consecutive windows (~6 sec)
    else if (detection_state.dysk_consecutive >= DETECTION_CONFIRM_WINDOWS) {
        dysk_intensity = (uint16_t)(detection_state.dysk_ema_intensity * 500.0f);  // Scale to 0-1000
        if (dysk_intensity > 1000) dysk_intensity = 1000;
        tremor_intensity = 0;  // Clear other condition
    }
    // Clear to NONE only after 3 consecutive windows (~9 sec)
    else if (detection_state.none_consecutive >= CLEAR_CONFIRM_WINDOWS) {
        tremor_intensity = 0;
        dysk_intensity = 0;
        detection_state.tremor_ema_intensity = 0.0f;  // Reset EMA when cleared
        detection_state.dysk_ema_intensity = 0.0f;
    }
    // Otherwise, keep previous state (no change)
    
    // Display confirmed result
    printf("‚Üí Confirmed: ");
    if (tremor_intensity > 0) {
        printf("üî¥ TREMOR [%u/%u] | Intensity: %u\n", 
               detection_state.tremor_consecutive, DETECTION_CONFIRM_WINDOWS, tremor_intensity);
    } else if (dysk_intensity > 0) {
        printf("üü† DYSK [%u/%u] | Intensity: %u\n", 
               detection_state.dysk_consecutive, DETECTION_CONFIRM_WINDOWS, dysk_intensity);
    } else {
        printf("‚úÖ NONE [%u/%u]\n", detection_state.none_consecutive, CLEAR_CONFIRM_WINDOWS);
    }
        
        // =========================================================================
        // PHASE 4: FOG (Freezing of Gait) Detection
        // =========================================================================
        
    // Calculate cadence (steps per minute)
    float window_duration_sec = WINDOW_SIZE / TARGET_SAMPLE_RATE_HZ;  // 3.0 seconds
    float cadence = (steps_in_window / window_duration_sec) * 60.0f;  // steps/min
        
        // Define thresholds (relaxed for easier testing)
        const float WALKING_CADENCE_MIN = 30.0f;     // Minimum for walking (relaxed)
        const float WALKING_CADENCE_MAX = 180.0f;    // Maximum realistic walking
        const float FREEZE_CADENCE_MAX = 15.0f;      // Nearly stopped
        const float WALKING_VARIANCE_MIN = 0.04f;    // Movement variance threshold (relaxed)
        const float FREEZE_VARIANCE_MAX = 0.03f;     // Very low movement (relaxed)
        const uint32_t MIN_WALKING_DURATION_MS = 3000;  // Must walk at least 3 seconds
        const uint32_t FREEZE_CONFIRMATION_MS = 2000;   // Freeze for 2s to confirm
        
        uint32_t current_time = Kernel::get_ms_count();
        bool currently_walking = (cadence >= WALKING_CADENCE_MIN && 
                                cadence <= WALKING_CADENCE_MAX &&
                                variance >= WALKING_VARIANCE_MIN);
        
    bool freeze_indicators = (cadence < FREEZE_CADENCE_MAX && 
                             variance < FREEZE_VARIANCE_MAX);
        
    // Safety check: Can't be in freeze states if never walked
    if ((fog_detector.state == FOG_POTENTIAL_FREEZE || fog_detector.state == FOG_FREEZE_CONFIRMED) &&
        fog_detector.walking_start_time == 0) {
        // Invalid state - reset to NOT_WALKING
        printf("   ‚ö†Ô∏è  WARNING: Invalid FOG state detected, resetting\n");
        fog_detector.state = FOG_NOT_WALKING;
        fog_detector.consecutive_walking_windows = 0;
        fog_detector.consecutive_freeze_windows = 0;
    }
    
    // State machine
    switch (fog_detector.state) {
        case FOG_NOT_WALKING: {
            if (currently_walking) {
                fog_detector.consecutive_walking_windows++;
                
                if (fog_detector.consecutive_walking_windows >= 2) {
                    fog_detector.state = FOG_WALKING;
                    fog_detector.walking_start_time = current_time;
                    fog_detector.consecutive_freeze_windows = 0;
                    printf("üö∂ Walking started | ");
        }
    } else {
                fog_detector.consecutive_walking_windows = 0;
            }
            break;
        }
            
        case FOG_WALKING: {
            uint32_t walking_duration = current_time - fog_detector.walking_start_time;
            
            if (currently_walking) {
                // Continue walking
            } else if (freeze_indicators) {
                if (walking_duration >= MIN_WALKING_DURATION_MS) {
                    fog_detector.state = FOG_POTENTIAL_FREEZE;
                    fog_detector.freeze_start_time = current_time;
                    fog_detector.consecutive_freeze_windows = 1;
                    printf("‚ö†Ô∏è Freeze? | ");
                } else {
                    fog_detector.state = FOG_NOT_WALKING;
                    fog_detector.consecutive_walking_windows = 0;
                }
            } else {
                fog_detector.state = FOG_NOT_WALKING;
                fog_detector.consecutive_walking_windows = 0;
            }
            break;
        }
            
        case FOG_POTENTIAL_FREEZE: {
            uint32_t freeze_duration = current_time - fog_detector.freeze_start_time;
            
            if (currently_walking) {
                fog_detector.state = FOG_WALKING;
                fog_detector.consecutive_freeze_windows = 0;
                printf("Resumed | ");
            } else if (freeze_indicators) {
                fog_detector.consecutive_freeze_windows++;
                
                if (freeze_duration >= FREEZE_CONFIRMATION_MS) {
                    fog_detector.state = FOG_FREEZE_CONFIRMED;
                    printf("‚ùÑÔ∏è FOG! | ");
                }
            } else {
                fog_detector.state = FOG_NOT_WALKING;
                fog_detector.consecutive_walking_windows = 0;
                fog_detector.consecutive_freeze_windows = 0;
            }
            break;
        }
            
        case FOG_FREEZE_CONFIRMED: {
            printf("‚ùÑÔ∏è FOG CONFIRMED | ");
            
            if (currently_walking) {
                fog_detector.state = FOG_WALKING;
                fog_detector.consecutive_freeze_windows = 0;
                printf("Recovered | ");
            }
            break;
        }
    }
    
    fog_detector.previous_cadence = cadence;
        
    // Reset step counter for next window
    steps_in_window = 0;
    
    // PHASE 5: Update FOG status for BLE (0 = NOFOG, 1 = FOG)
    if (fog_detector.state == FOG_FREEZE_CONFIRMED) {
        fog_status = 1;  // FOG detected
    } else {
        fog_status = 0;  // No FOG
    }
    
    // BLE update
    if (ble_connected) {
        printf("BLE: Tremor=%u, Dysk=%u, FOG=%u ‚úì\n", tremor_intensity, dysk_intensity, fog_status);
        update_ble_characteristics();
    } else {
        printf("BLE: Not connected\n");
    }
}

// =============================================================================
// BLE Functions
// =============================================================================

void schedule_ble_events(BLE::OnEventsToProcessCallbackContext *context) {
    ble_event_queue.call(Callback<void()>(&context->ble, &BLE::processEvents));
}

void on_ble_init_complete(BLE::InitializationCompleteCallbackContext *params) {
    if (params->error != BLE_ERROR_NONE) {
        printf("‚ùå BLE initialization failed\n");
        return;
    }
    
    printf("‚úì BLE initialized successfully\n");

    BLE &ble = params->ble;
    gatt_server = &ble.gattServer();
    
    // Create characteristics with notify capability
    // Three characteristics for three conditions (Tremor, Dyskinesia, FOG)
    tremor_char = new GattCharacteristic(
        TREMOR_CHAR_UUID,
        (uint8_t*)&tremor_intensity,
        sizeof(tremor_intensity),
        sizeof(tremor_intensity),
        GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY
    );
    
    dysk_char = new GattCharacteristic(
        DYSK_CHAR_UUID,
        (uint8_t*)&dysk_intensity,
        sizeof(dysk_intensity),
        sizeof(dysk_intensity),
        GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY
    );
    
    fog_char = new GattCharacteristic(
        FOG_CHAR_UUID,
        (uint8_t*)&fog_status,
        sizeof(fog_status),
        sizeof(fog_status),
        GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY
    );
    
    // Create service with characteristics
    GattCharacteristic *char_table[] = {tremor_char, dysk_char, fog_char};
    GattService pd_service(PD_SERVICE_UUID, char_table, 3);
    
    // Add service to GATT server
    gatt_server->addService(pd_service);
    
    // Setup advertising
    ble::AdvertisingParameters adv_params(
        ble::advertising_type_t::CONNECTABLE_UNDIRECTED,
        ble::adv_interval_t(ble::millisecond_t(1000))
    );
    
    ble.gap().setAdvertisingParameters(ble::LEGACY_ADVERTISING_HANDLE, adv_params);
    
    // Build advertising data
    uint8_t adv_buffer[ble::LEGACY_ADVERTISING_MAX_SIZE];
    ble::AdvertisingDataBuilder adv_data_builder(adv_buffer);
    
    adv_data_builder.setFlags();
    adv_data_builder.setName("PD_Detector");
    
    // Set advertising payload
    ble_error_t error = ble.gap().setAdvertisingPayload(
        ble::LEGACY_ADVERTISING_HANDLE,
        adv_data_builder.getAdvertisingData()
    );
    
    if (error != BLE_ERROR_NONE) {
        printf("‚ùå Failed to set advertising payload\n");
        return;
    }
    
    // Start advertising
    error = ble.gap().startAdvertising(ble::LEGACY_ADVERTISING_HANDLE);
    
    if (error != BLE_ERROR_NONE) {
        printf("‚ùå Failed to start advertising\n");
        return;
    }

    printf("‚úì BLE advertising started\n");
    printf("‚úì Device name: \"PD_Detector\"\n");
    printf("‚úì Ready to connect from phone!\n\n");
}

class PDGapEventHandler : public ble::Gap::EventHandler {
    void onConnectionComplete(const ble::ConnectionCompleteEvent &event) override {
        if (event.getStatus() == BLE_ERROR_NONE) {
            ble_connected = true;
            printf("\nüì± BLE Device Connected!\n\n");
        }
    }
    
    void onDisconnectionComplete(const ble::DisconnectionCompleteEvent &event) override {
        ble_connected = false;
        printf("\nüì± BLE Device Disconnected\n\n");
        
        // Restart advertising
        ble_instance.gap().startAdvertising(ble::LEGACY_ADVERTISING_HANDLE);
        printf("‚úì Advertising restarted\n\n");
    }
};

static PDGapEventHandler gap_event_handler;

void update_ble_characteristics() {
    if (!ble_connected || gatt_server == nullptr) return;

    bool tremor_changed = (tremor_intensity != previous_tremor);
    bool dysk_changed = (dysk_intensity != previous_dysk);
    bool fog_changed = (fog_status != previous_fog);

    if (tremor_changed) {
        gatt_server->write(
            tremor_char->getValueHandle(),
            (uint8_t*)&tremor_intensity,
            sizeof(tremor_intensity)
        );

        if (tremor_intensity > 0) {
            printf("   üì¢ BLE NOTIFICATION: TREMOR intensity = %u\n", tremor_intensity);
        } else {
            printf("   üì¢ BLE NOTIFICATION: TREMOR cleared\n");
        }

        previous_tremor = tremor_intensity;
    }

    if (dysk_changed) {
        gatt_server->write(
            dysk_char->getValueHandle(),
            (uint8_t*)&dysk_intensity,
            sizeof(dysk_intensity)
        );

        if (dysk_intensity > 0) {
            printf("   üì¢ BLE NOTIFICATION: DYSK intensity = %u\n", dysk_intensity);
        } else {
            printf("   üì¢ BLE NOTIFICATION: DYSK cleared\n");
        }

        previous_dysk = dysk_intensity;
    }

    if (fog_changed) {
        gatt_server->write(
            fog_char->getValueHandle(),
            (uint8_t*)&fog_status,
            sizeof(fog_status)
        );

        if (fog_status == 1) {
            printf("   üì¢ BLE NOTIFICATION: FOG detected!\n");
        } else {
            printf("   üì¢ BLE NOTIFICATION: FOG cleared\n");
        }

        previous_fog = fog_status;
    }

    if (tremor_changed || dysk_changed || fog_changed) {
        printf("   BLE characteristics updated and notifications sent!\n");
    }
}

// =============================================================================
// Main Function
// =============================================================================

int main() {
        // Startup banner
        printf("\n\n");
        printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïë   PARKINSON'S DISEASE MOVEMENT DETECTOR                       ‚ïë\n");
        printf("‚ïë   Phases 1-4: Full Detection System                          ‚ïë\n");
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïë   Board: STM32 DISCO-L475VG-IOT01A                            ‚ïë\n");
        printf("‚ïë   Sensor: LSM6DSL (Accel + Gyro)                              ‚ïë\n");
        printf("‚ïë   Sample Rate: %.0f Hz | Window: 3 sec | FFT: %zu points       ‚ïë\n", 
            TARGET_SAMPLE_RATE_HZ, FFT_SIZE);
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïë   Detection Capabilities:                                     ‚ïë\n");
        printf("‚ïë   üî¥ Tremor: 3-5 Hz rhythmic oscillations                     ‚ïë\n");
        printf("‚ïë   üü† Dyskinesia: 5-7 Hz dance-like movements                  ‚ïë\n");
        printf("‚ïë   ‚ùÑÔ∏è  FOG: Freezing after walking (step detection)            ‚ïë\n");
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    printf("\n");

        // Configure I2C frequency (400kHz = fast mode)
    i2c.frequency(400000);
        printf("I2C configured at 400kHz\n\n");

        // Initialize sensor
        if (!init_lsm6dsl()) {
        printf("\n");
            printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
            printf("‚ïë                    ‚ùå INITIALIZATION FAILED ‚ùå                 ‚ïë\n");
            printf("‚ïë                                                               ‚ïë\n");
            printf("‚ïë  Check:                                                       ‚ïë\n");
            printf("‚ïë  1. Sensor connections (I2C: PB_11=SDA, PB_10=SCL)            ‚ïë\n");
            printf("‚ïë  2. Power supply                                              ‚ïë\n");
            printf("‚ïë  3. I2C address (0x6A)                                        ‚ïë\n");
            printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
            
            // Blink LED rapidly to indicate error
        while (true) { 
                led = !led;
                ThisThread::sleep_for(200ms);
        }
    }

    // Attach interrupt handler
    data_ready_pin.rise(&data_ready_isr);
    printf("‚úì Interrupt handler attached to INT1 pin\n\n");

    // Initialize BLE
    printf("Initializing BLE...\n");
    ble_instance.onEventsToProcess(schedule_ble_events);
    ble_instance.gap().setEventHandler(&gap_event_handler);
    ble_instance.init(on_ble_init_complete);
    
    // Wait a bit for BLE to initialize
    ThisThread::sleep_for(500ms);
        
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                üöÄ STARTING DETECTION SYSTEM üöÄ                ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  ACTIVE FEATURES:                                             ‚ïë\n");
    printf("‚ïë  ‚úì 52 Hz interrupt-driven sampling                            ‚ïë\n");
    printf("‚ïë  ‚úì 3-second windowed data collection                          ‚ïë\n");
    printf("‚ïë  ‚úì FFT-based frequency analysis                               ‚ïë\n");
    printf("‚ïë  ‚úì Tremor detection (3-5 Hz)                                  ‚ïë\n");
    printf("‚ïë  ‚úì Dyskinesia detection (5-7 Hz)                              ‚ïë\n");
    printf("‚ïë  ‚úì FOG detection (step tracking + gait analysis)              ‚ïë\n");
    printf("‚ïë  ‚úì BLE data transmission (Phase 5)                            ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  BLE ADVERTISING:                                             ‚ïë\n");
    printf("‚ïë  Device Name: \"PD_Detector\"                                 ‚ïë\n");
    printf("‚ïë  (Note: Full BLE transmission available via app)              ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  TEST SCENARIOS:                                              ‚ïë\n");
    printf("‚ïë  üî¥ Shake slowly (4 Hz) ‚Üí Tremor                              ‚ïë\n");
    printf("‚ïë  üü† Shake fast (6 Hz) ‚Üí Dyskinesia                            ‚ïë\n");
    printf("‚ïë  ‚ùÑÔ∏è  Walk in place, then stop ‚Üí FOG                           ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
        
        uint32_t last_diagnostic_time = 0;
        uint32_t last_poll_time = 0;
        
        // Main loop
    while (true) {
        uint32_t now = Kernel::get_ms_count();
            
            // Diagnostic output every 10 seconds (reduced frequency)
            if (now - last_diagnostic_time >= 10000) {
                printf("\nüíö System Health: %lu interrupts | %lu samples | %u windows\n", 
                    interrupt_count, sample_count, window_count);
                last_diagnostic_time = now;
            }
            
            // Method 1: Check interrupt flag (preferred method)
            if (new_data_available) {
                new_data_available = false;
                read_sensor_data();
            }
            // Method 2: Polling fallback - check STATUS_REG periodically
            // This will work even if interrupts aren't firing
            else if (now - last_poll_time >= 19) {  // ~52Hz = 19ms period
                last_poll_time = now;
                
                // Check if data is actually ready
                uint8_t status = 0;
                if (read_register(STATUS_REG, status)) {
                    // Bit 0 = XLDA (accel data available)
                    // Bit 1 = GDA (gyro data available)
                    bool accel_ready = (status & 0x01) != 0;
                    bool gyro_ready = (status & 0x02) != 0;
                    
                    if (accel_ready && gyro_ready) {
                        // Data is available but interrupt didn't fire!
                        // Read it anyway using polling mode
                        read_sensor_data();
                    }
                }
            }
            
        // PHASE 2: Check if a complete window is ready for processing
        if (window_ready) {
            process_window();
        }
        
        // Process BLE events
        ble_event_queue.dispatch_once();
        
        // Small delay to prevent busy-waiting h
        ThisThread::sleep_for(1ms);
    }
}


