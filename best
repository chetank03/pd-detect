/**
 * @file main.cpp
 * @brief Parkinson's Disease Movement Detection System
 * @author RTES Challenge Implementation
 * @date December 2025
 * 
 * @description
 * Real-time detection system for Parkinson's disease motor symptoms using
 * STM32 DISCO-L475VG-IOT01A board with LSM6DSL motion sensor.
 * 
 * Features:
 * - 52Hz interrupt-driven data acquisition
 * - 3-second windowed FFT analysis
 * - Tremor detection (3-5Hz rhythmic oscillations)
 * - Dyskinesia detection (5-7Hz dance-like movements) 
 * - Freezing of Gait (FOG) detection via step analysis
 * - BLE transmission with three characteristics
 * - Visual LED indication with intensity feedback
 * 
 * Hardware Requirements:
 * - STM32 DISCO-L475VG-IOT01A development board
 * - LSM6DSL accelerometer/gyroscope sensor
 * - CMSIS-DSP library for FFT processing
 */

#include "mbed.h"
#include "arm_math.h"  // CMSIS-DSP library for FFT
#include <math.h>      // For cosf() in Hann window
#include <cstring>
// BLE includes
#include "ble/BLE.h"
#include "ble/Gap.h"
#include "ble/GattServer.h"
#include "ble/gatt/GattCharacteristic.h"
#include "ble/gatt/GattService.h"
#include "ble/gap/AdvertisingDataBuilder.h"
#include "events/EventQueue.h"

// =============================================================================
// Hardware Configuration & System Setup
// =============================================================================

// I2C communication interface for LSM6DSL sensor
I2C i2c(PB_11, PB_10);  // SDA=PB_11, SCL=PB_10 (400kHz fast mode)

// Hardware interrupt for sensor data-ready signal
InterruptIn data_ready_pin(PD_11, PullDown);

// LED for visual status indication
DigitalOut led(LED1);

// Serial console configuration for debug output
BufferedSerial serial_port(USBTX, USBRX, 115200);
FileHandle *mbed::mbed_override_console(int) {
    return &serial_port;
}

// =============================================================================
// LSM6DSL Sensor Register Map & Configuration
// =============================================================================

#define LSM6DSL_ADDR        (0x6A << 1)  // I2C device address (7-bit left-shifted)

// Control and status registers
#define WHO_AM_I            0x0F  // Device identification register
#define CTRL1_XL            0x10  // Accelerometer control register
#define CTRL2_G             0x11  // Gyroscope control register  
#define CTRL3_C             0x12  // Common control register
#define INT1_CTRL           0x0D  // Interrupt 1 control register
#define STATUS_REG          0x1E  // Data status register

// Data output registers (auto-increment enabled)
#define OUTX_L_XL           0x28  // Accelerometer data start address
#define OUTX_L_G            0x22  // Gyroscope data start address

// Device identification value
#define LSM6DSL_WHO_AM_I_VAL  0x6A

// =============================================================================
// Signal Processing Configuration
// =============================================================================

/** Target sampling frequency for motion data acquisition */
const float TARGET_SAMPLE_RATE_HZ = 52.0f;

/** Analysis window parameters for frequency domain processing */
const size_t WINDOW_SIZE = 156;  // 3.0 seconds √ó 52 Hz = 156 samples
const size_t FFT_SIZE = 256;     // Zero-padded to next power of 2 for efficiency

// =============================================================================
// System State Variables
// =============================================================================

/** Interrupt and data acquisition control */
volatile bool new_data_available = false;    // ISR flag for new sensor data
volatile uint32_t interrupt_count = 0;       // Total interrupt count for diagnostics
volatile uint32_t pending_samples = 0;       // Number of unprocessed samples in ISR
uint32_t sample_count = 0;                   // Total samples processed
uint32_t last_sample_time_ms = 0;            // Timestamp of last sample (for rate calc)

// =============================================================================
// FFT Processing & Signal Analysis
// =============================================================================

/** CMSIS-DSP FFT instance (initialized once for efficiency) */
static arm_rfft_fast_instance_f32 fft_instance;
static bool fft_initialized = false;

/** Pre-computed Hann window coefficients for spectral leakage reduction */
static float hann_window[WINDOW_SIZE];
static bool hann_computed = false;

/** Global FFT processing arrays (reused across analysis windows) */
static float combined_data[WINDOW_SIZE];      // Normalized sensor fusion data
static float accel_norm[WINDOW_SIZE], gyro_norm[WINDOW_SIZE];  // DC-removed data
static float fft_input[FFT_SIZE];             // Zero-padded FFT input buffer
static float fft_output[FFT_SIZE];            // Complex FFT output buffer
static float magnitude_spectrum[FFT_SIZE/2];  // Frequency domain magnitudes

// =============================================================================
// Data Acquisition & Windowing
// =============================================================================

/** Circular buffers for 3-second data windows */
float accel_magnitude_buffer[WINDOW_SIZE];  // Accelerometer magnitude history
float gyro_magnitude_buffer[WINDOW_SIZE];   // Gyroscope magnitude history  
size_t buffer_index = 0;                    // Current write position in buffers
volatile bool window_ready = false;         // Flag: complete window ready for processing
uint32_t window_count = 0;                  // Total windows processed (diagnostics)

// =============================================================================
// Freezing of Gait (FOG) Detection System
// =============================================================================

/** Step detection parameters (tuned for vertical axis sensitivity) */
const float STEP_THRESHOLD = 0.05f;          // Lowered from 0.10f - more sensitive step detection
const uint32_t MIN_STEP_INTERVAL_MS = 100;   // Lowered from 150ms - faster step detection

/** Step tracking variables */
uint16_t steps_in_window = 0;                // Steps detected in current 3-second window
bool above_step_threshold = false;           // Peak detection state machine flag
    uint32_t last_step_time_ms = 0;              // Timestamp of last step
    
    // EMA baseline for adaptive step detection
    float accel_baseline_ema = 1.0f;             // EMA of accelerometer Z-axis baseline
    const float BASELINE_EMA_ALPHA = 0.001f;     // Very slow adaptation (0.1% per sample)

    // FOG state machine
    enum FOGState {
        FOG_NOT_WALKING,
        FOG_WALKING,
        FOG_POTENTIAL_FREEZE,
        FOG_FREEZE_CONFIRMED
    };

struct FOGDetector {
    FOGState state;
    uint32_t walking_start_time;
    uint32_t freeze_start_time;
    float previous_cadence;
    uint8_t consecutive_walking_windows;
    uint8_t consecutive_freeze_windows;
} fog_detector = {FOG_NOT_WALKING, 0, 0, 0.0f, 0, 0};

// =============================================================================
// Bluetooth Low Energy (BLE) Communication System
// =============================================================================

/**
 * Detection results transmitted via BLE to mobile device
 * Three separate characteristics for real-time monitoring:
 * 
 * @tremor_intensity: 0-1000 scale (0=none, 1000=maximum intensity)
 * @dysk_intensity:   0-1000 scale (0=none, 1000=maximum intensity)  
 * @fog_status:       Binary flag (0=NO_FOG, 1=FOG_DETECTED)
 */
static uint16_t tremor_intensity = 0;           
static uint16_t dysk_intensity = 0;             
static uint16_t fog_status = 0;                 
static bool ble_connected = false;              // Connection status flag

// =============================================================================
// Visual Indication System (LED Pattern Control)
// =============================================================================

/** LED pattern timing constants for different detection states */
const uint32_t TREMOR_TOTAL_PERIOD_MS = 500;     // 2Hz pattern (500ms cycle)
const uint32_t DYSK_TOTAL_PERIOD_MS = 250;       // 4Hz pattern (250ms cycle)  
const uint32_t FOG_CYCLE_PERIOD_MS = 1000;       // Triple-blink alarm cycle
const uint32_t HEARTBEAT_PERIOD_MS = 2000;       // System alive indicator

/** Change detection for BLE notifications */
static uint16_t previous_tremor = 0;
static uint16_t previous_dysk = 0;
static uint16_t previous_fog = 0;

/** Multi-window confirmation system for robust detection */
struct DetectionConfirmation {
    char last_raw_detection[16];    // Last raw detection from FFT
    uint8_t tremor_consecutive;      // Consecutive tremor detections
    uint8_t dysk_consecutive;        // Consecutive dyskinesia detections
    uint8_t none_consecutive;        // Consecutive "NONE" detections
    float tremor_ema_intensity;      // EMA smoothed intensity for tremor
    float dysk_ema_intensity;        // EMA smoothed intensity for dyskinesia
} detection_state = {"NONE", 0, 0, 0, 0.0f, 0.0f};

const uint8_t DETECTION_CONFIRM_WINDOWS = 2;  // Need 2 consecutive windows (~6 sec) for realistic confirmation
const uint8_t CLEAR_CONFIRM_WINDOWS = 3;      // Need 3 consecutive windows (~9 sec) to clear symptoms
const float EMA_ALPHA = 0.3f;                 // More stable smoothing for medical reliability

// BLE objects
using namespace ble;
events::EventQueue ble_event_queue(16 * EVENTS_EVENT_SIZE);
BLE &ble_instance = BLE::Instance();

// UUIDs for service and characteristics
// Three characteristics for three conditions (Tremor, Dyskinesia, FOG)
const UUID PD_SERVICE_UUID("A0E1B2C3-D4E5-F6A7-B8C9-D0E1F2A3B4C5");
const UUID TREMOR_CHAR_UUID("A1E2B3C4-D5E6-F7A8-B9C0-D1E2F3A4B5C6");
const UUID DYSK_CHAR_UUID("A2E3B4C5-D6E7-F8A9-B0C1-D2E3F4A5B6C7");
const UUID FOG_CHAR_UUID("A3E4B5C6-D7E8-F9AA-B1C2-D3E4F5A6B7C8");

// GattCharacteristic pointers (will be created after BLE init)
GattCharacteristic *tremor_char = nullptr;
GattCharacteristic *dysk_char = nullptr;
GattCharacteristic *fog_char = nullptr;
GattServer *gatt_server = nullptr;

// Forward declaration
void update_ble_characteristics();

// =============================================================================
// I2C Communication Helper Functions
// =============================================================================

/**
 * @brief Write a single byte to LSM6DSL register
 * @param reg Register address
 * @param value Data byte to write
 * @return true if successful, false on I2C error
 */
bool write_register(uint8_t reg, uint8_t value) {
        char data[2] = {(char)reg, (char)value};
        int result = i2c.write(LSM6DSL_ADDR, data, 2);
        return (result == 0);  // 0 = success
    }

/**
 * @brief Read a single byte from LSM6DSL register
 * @param reg Register address
 * @param value Reference to store read data
 * @return true if successful, false on I2C error
 */
bool read_register(uint8_t reg, uint8_t &value) {
        char reg_addr = (char)reg;
        
        // Write register address
        if (i2c.write(LSM6DSL_ADDR, &reg_addr, 1, true) != 0) {
            return false;
        }
        
        // Read data
        char data;
        if (i2c.read(LSM6DSL_ADDR, &data, 1) != 0) {
            return false;
        }
        
        value = (uint8_t)data;
    return true;
}

/**
 * @brief Read multiple bytes from LSM6DSL (auto-increment enabled)
 * @param start_reg Starting register address
 * @param buffer Destination buffer for read data
 * @param length Number of bytes to read
 * @return true if successful, false on I2C error
 */
bool read_burst(uint8_t start_reg, uint8_t *buffer, uint8_t length) {
        char reg_addr = (char)start_reg;
        
        // Write register address
        if (i2c.write(LSM6DSL_ADDR, &reg_addr, 1, true) != 0) {
            return false;
        }
        
        // Read data
        if (i2c.read(LSM6DSL_ADDR, (char*)buffer, length) != 0) {
            return false;
        }
        
        return true;
    }

    /**
    * Read a 16-bit value (low byte first, then high byte)
    */
    bool read_int16(uint8_t reg_low, int16_t &value) {
        uint8_t low_byte, high_byte;
        
        if (!read_register(reg_low, low_byte)) return false;
        if (!read_register(reg_low + 1, high_byte)) return false;
        
        value = (int16_t)((high_byte << 8) | low_byte);
    return true;
}

// =============================================================================
// LSM6DSL Sensor Initialization & Configuration
// =============================================================================

/**
 * @brief Initialize and configure LSM6DSL sensor for motion detection
 * @return true if initialization successful, false on error
 * 
 * Configuration:
 * - Accelerometer: 52Hz ODR, ¬±2g range, 400Hz bandwidth
 * - Gyroscope: 52Hz ODR, ¬±250dps range
 * - Interrupts: Data-ready on INT1 pin
 * - I2C: Auto-increment enabled, block data update
 */
bool init_lsm6dsl() {
        printf("\n=== Initializing LSM6DSL Sensor ===\n");
        
        // Step 1: Check WHO_AM_I register
        printf("1. Checking WHO_AM_I register...\n");
        uint8_t who_am_i = 0;
        if (!read_register(WHO_AM_I, who_am_i)) {
            printf("   ‚ùå ERROR: Cannot read WHO_AM_I register\n");
        return false;
    }

        printf("   WHO_AM_I = 0x%02X (expected 0x%02X)\n", who_am_i, LSM6DSL_WHO_AM_I_VAL);
        
        if (who_am_i != LSM6DSL_WHO_AM_I_VAL) {
            printf("   ‚ùå ERROR: Wrong device ID\n");
            return false;
        }
        printf("   ‚úì Correct device detected\n\n");
        
        // Step 2: Configure CTRL3_C (Common settings)
        printf("2. Configuring common settings (CTRL3_C)...\n");
        // BDU=1 (Block Data Update), IF_INC=1 (Auto-increment address)
        if (!write_register(CTRL3_C, 0x44)) {
            printf("   ‚ùå ERROR: Cannot write CTRL3_C\n");
            return false;
        }
        printf("   ‚úì BDU and auto-increment enabled\n\n");
        
        // Step 3: Configure Accelerometer (CTRL1_XL)
        printf("3. Configuring accelerometer (CTRL1_XL)...\n");
        // ODR = 52Hz (0011b), FS = ¬±2g (00b), BW = 400Hz (00b)
        // Register value: 0011 00 00 = 0x30
        if (!write_register(CTRL1_XL, 0x30)) {
            printf("   ‚ùå ERROR: Cannot write CTRL1_XL\n");
            return false;
        }
        printf("   ‚úì Accelerometer: 52Hz, ¬±2g\n\n");
        
        // Step 4: Configure Gyroscope (CTRL2_G)
        printf("4. Configuring gyroscope (CTRL2_G)...\n");
        // ODR = 52Hz (0011b), FS = ¬±250dps (00b)
        // Register value: 0011 00 00 = 0x30
        if (!write_register(CTRL2_G, 0x30)) {
            printf("   ‚ùå ERROR: Cannot write CTRL2_G\n");
            return false;
        }
        printf("   ‚úì Gyroscope: 52Hz, ¬±250dps\n\n");
        
        // Step 5: Configure INT1 pin for data-ready
        printf("5. Configuring INT1 pin (INT1_CTRL)...\n");
        // INT1_DRDY_XL=1 (bit 0), INT1_DRDY_G=1 (bit 1)
        // Register value: 0000 0011 = 0x03
        if (!write_register(INT1_CTRL, 0x03)) {
            printf("   ‚ùå ERROR: Cannot write INT1_CTRL\n");
            return false;
        }
        printf("   ‚úì INT1 configured for accel+gyro data-ready\n\n");
        
        // Step 6: Clear any pending data by reading STATUS_REG
    uint8_t dummy;
        read_register(STATUS_REG, dummy);

        printf("=== LSM6DSL Initialization Complete ===\n\n");
    return true;
}

// =============================================================================
// Interrupt Service Routine
// =============================================================================

/**
 * @brief ISR for sensor data-ready interrupt
 * @note Called when INT1 pin goes high (new data available)
 *       Counts pending samples to prevent loss during main loop delays
 */
void data_ready_isr() {
    new_data_available = true;
    interrupt_count++;
    pending_samples++;  // Count how many samples are waiting
}

// =============================================================================
// Data Acquisition & Processing
// =============================================================================

/**
 * @brief Read and process one sensor sample
 * @note Performs sensor data acquisition, magnitude calculation,
 *       circular buffer management, and step detection for FOG analysis
 */
void read_sensor_data() {
        // Read raw accelerometer data (6 bytes: X,Y,Z as 16-bit each) - BURST READ
        uint8_t accel_data[6];
        if (!read_burst(OUTX_L_XL, accel_data, 6)) return;
        
        int16_t accel_x_raw = (int16_t)((accel_data[1] << 8) | accel_data[0]);  // X: [1][0]
        int16_t accel_y_raw = (int16_t)((accel_data[3] << 8) | accel_data[2]);  // Y: [3][2]
        int16_t accel_z_raw = (int16_t)((accel_data[5] << 8) | accel_data[4]);  // Z: [5][4]
        
        // Read raw gyroscope data (6 bytes: X,Y,Z as 16-bit each) - BURST READ
        uint8_t gyro_data[6];
        if (!read_burst(OUTX_L_G, gyro_data, 6)) return;
        
        int16_t gyro_x_raw = (int16_t)((gyro_data[1] << 8) | gyro_data[0]);  // X: [1][0]
        int16_t gyro_y_raw = (int16_t)((gyro_data[3] << 8) | gyro_data[2]);  // Y: [3][2]
        int16_t gyro_z_raw = (int16_t)((gyro_data[5] << 8) | gyro_data[4]);  // Z: [5][4]
        
        // Convert to physical units
        // Accelerometer: ¬±2g range, 16-bit resolution
        // Sensitivity = 0.061 mg/LSB = 0.000061 g/LSB (from datasheet)
        const float ACCEL_SCALE = 0.000061f;  // g per LSB
        float accel_x = accel_x_raw * ACCEL_SCALE;
        float accel_y = accel_y_raw * ACCEL_SCALE;
        float accel_z = accel_z_raw * ACCEL_SCALE;
        
        // Gyroscope: ¬±250dps range, 16-bit resolution  
        // Sensitivity = 8.75 mdps/LSB (from datasheet)
        const float GYRO_SCALE = 0.00875f;  // dps per LSB
        float gyro_x = gyro_x_raw * GYRO_SCALE;
        float gyro_y = gyro_y_raw * GYRO_SCALE;
        float gyro_z = gyro_z_raw * GYRO_SCALE;
        
        // Calculate magnitudes (what we'll use for tremor/dyskinesia detection)
        float accel_magnitude = sqrtf(accel_x*accel_x + accel_y*accel_y + accel_z*accel_z);
        float gyro_magnitude = sqrtf(gyro_x*gyro_x + gyro_y*gyro_y + gyro_z*gyro_z);
        
        // Calculate actual sampling rate
        uint32_t current_time = Kernel::get_ms_count();
        float actual_period_ms = 0.0f;
        
        if (sample_count > 0) {
            actual_period_ms = current_time - last_sample_time_ms;
        }
        last_sample_time_ms = current_time;
        
        sample_count++;
        
        // =========================================================================
        // PHASE 2: Store accelerometer and gyroscope magnitudes in circular buffers
        // =========================================================================
        accel_magnitude_buffer[buffer_index] = accel_magnitude;
        gyro_magnitude_buffer[buffer_index] = gyro_magnitude;
        buffer_index++;
        
        // Check if we've collected a full 3-second window
        if (buffer_index >= WINDOW_SIZE) {
            buffer_index = 0;  // Wrap around (circular buffer)
            window_ready = true;  // Signal that window is ready for processing
        }
        
        // =========================================================================
        // PHASE 4: Step Detection for FOG Analysis (Vertical Axis Only)
        // =========================================================================
        // Use only Z-axis (vertical) to avoid tremor false triggers from hand movement
        // Walking steps primarily show up as vertical acceleration patterns
        
        // Update EMA baseline for vertical axis only
        accel_baseline_ema = BASELINE_EMA_ALPHA * accel_z + 
                            (1.0f - BASELINE_EMA_ALPHA) * accel_baseline_ema;
        
        // Detect steps using vertical axis deviation from adaptive baseline
        float vertical_deviation = fabsf(accel_z - accel_baseline_ema);
        uint32_t now = Kernel::get_ms_count();

        // Peak detection: rising edge above threshold (vertical axis only)
        if (vertical_deviation > STEP_THRESHOLD && !above_step_threshold) {
            // Check minimum time between steps (avoid double-counting)
            if (now - last_step_time_ms > MIN_STEP_INTERVAL_MS) {
                steps_in_window++;
                last_step_time_ms = now;
            }
            above_step_threshold = true;
        } 
        // Falling edge below threshold (reset for next peak)
        else if (vertical_deviation < STEP_THRESHOLD * 0.5f) {
            above_step_threshold = false;
        }
        
    // Compact status update (every 52 samples = ~1 second) - DISABLED for cleaner output
    // Uncomment next 2 lines if you want per-second updates:
    // if (sample_count % 52 == 0) {
    //     printf("[%lu s] %.1fHz | %.3fg\n", current_time/1000, actual_rate_hz, accel_magnitude);
    // }
    
    // LED patterns are now handled by update_led_indication() function
        
        // Minimal Teleplot data (only key metrics for visualization)
        // Uncomment if you want to use Teleplot or similar graphing tools:
        // printf(">accel_mag:%.3f\n", accel_magnitude);
        // printf(">buffer_progress:%zu\n", buffer_index);
    }

// =============================================================================
// Visual Indication System (LED Pattern Control)
// =============================================================================

/**
 * @brief Update LED1 to visually indicate current detection state
 * @note Uses phase-based timing for consistent patterns:
 *       - Tremor: 2Hz blink with intensity-proportional duty cycle
 *       - Dyskinesia: 4Hz blink with intensity-proportional duty cycle  
 *       - FOG: Fast triple-blink alarm pattern
 *       - Normal: Slow heartbeat (system alive indicator)
 */
void update_led_indication() {
        uint32_t now = Kernel::get_ms_count();
        
        // Priority: FOG > Tremor > Dyskinesia > None
        if (fog_status == 1) {
            // FOG ALARM: Triple-blink pattern (ON-OFF-ON-OFF-ON-OFF, then pause)
            // Pattern: 100ms ON, 100ms OFF, 100ms ON, 100ms OFF, 100ms ON, 500ms OFF = 1000ms total
            uint32_t phase = now % FOG_CYCLE_PERIOD_MS;
            bool blink_on = ((phase < 100) || (phase >= 200 && phase < 300) || (phase >= 400 && phase < 500));
            led = blink_on;
        }
        else if (tremor_intensity > 0) {
            // TREMOR: 2Hz blink with intensity-proportional duty cycle
            uint32_t phase = now % TREMOR_TOTAL_PERIOD_MS;
            uint32_t duty_cycle_percent = 20 + ((tremor_intensity * 60) / 1000);  // 20-80% duty cycle
            uint32_t on_time_ms = (TREMOR_TOTAL_PERIOD_MS * duty_cycle_percent) / 100;
            led = (phase < on_time_ms);
        }
        else if (dysk_intensity > 0) {
            // DYSKINESIA: 4Hz blink with intensity-proportional duty cycle
            uint32_t phase = now % DYSK_TOTAL_PERIOD_MS;
            uint32_t duty_cycle_percent = 20 + ((dysk_intensity * 60) / 1000);  // 20-80% duty cycle
            uint32_t on_time_ms = (DYSK_TOTAL_PERIOD_MS * duty_cycle_percent) / 100;
            led = (phase < on_time_ms);
        }
        else {
            // NO CONDITIONS: Slow heartbeat (0.5Hz = 2000ms period, 10% duty cycle)
            uint32_t phase = now % HEARTBEAT_PERIOD_MS;
            led = (phase < 200);  // 200ms on, 1800ms off
        }
    }

// =============================================================================
// Signal Processing & Frequency Domain Analysis
// =============================================================================

    /**
    * Perform FFT analysis and detect tremor/dyskinesia
    * Returns raw detection (before multi-window confirmation)
    * Uses both accelerometer and gyroscope data for robustness
    * 
    * @param accel_data - Array of accelerometer magnitude samples
    * @param gyro_data - Array of gyroscope magnitude samples
    * @param size - Number of samples (should be WINDOW_SIZE = 156)
    * @param sample_rate - Sampling frequency in Hz
    * @param[out] raw_condition - Raw detection result ("NONE", "TREMOR", "DYSK")
    * @param[out] raw_intensity - Raw intensity value
    */
    void analyze_frequency_content(float* accel_data, float* gyro_data, size_t size, float sample_rate,
                                   char* raw_condition, float* raw_intensity) {
        // Defaults
        strcpy(raw_condition, "NONE");
        *raw_intensity = 0.0f;

        // FFT init once
        if (!fft_initialized) {
            arm_status st = arm_rfft_fast_init_f32(&fft_instance, FFT_SIZE);
            if (st != ARM_MATH_SUCCESS) {
                printf("‚ùå FFT init failed\n");
                return;
            }
            fft_initialized = true;
        }

        // Hann once
        if (!hann_computed) {
            const float pi = 3.14159265359f;
            for (size_t i = 0; i < WINDOW_SIZE; i++) {
                hann_window[i] = 0.5f * (1.0f - cosf(2.0f * pi * i / (WINDOW_SIZE - 1)));
            }
            hann_computed = true;
        }

        // --- 1) DC remove + std for accel/gyro ---
        float accel_sum = 0.0f, gyro_sum = 0.0f;
        for (size_t i = 0; i < size; i++) { accel_sum += accel_data[i]; gyro_sum += gyro_data[i]; }
        const float accel_mean = accel_sum / (float)size;
        const float gyro_mean  = gyro_sum  / (float)size;

        float accel_var = 0.0f, gyro_var = 0.0f;
        for (size_t i = 0; i < size; i++) {
            accel_norm[i] = accel_data[i] - accel_mean;
            gyro_norm[i]  = gyro_data[i]  - gyro_mean;
            accel_var += accel_norm[i] * accel_norm[i];
            gyro_var  += gyro_norm[i]  * gyro_norm[i];
        }

        const float eps = 1e-6f;
        const float accel_std = sqrtf(accel_var / (float)size) + eps;
        const float gyro_std  = sqrtf(gyro_var  / (float)size) + eps;

        // Combine (z-score each, then weighted sum)
        for (size_t i = 0; i < size; i++) {
            float az = accel_norm[i] / accel_std;
            float gz = gyro_norm[i]  / gyro_std;
            combined_data[i] = 0.7f * az + 0.3f * gz;
        }

        // --- 2) Window + zero pad ---
        for (size_t i = 0; i < size; i++) fft_input[i] = combined_data[i] * hann_window[i];
        for (size_t i = size; i < FFT_SIZE; i++) fft_input[i] = 0.0f;

        // --- 3) FFT ---
        arm_rfft_fast_f32(&fft_instance, fft_input, fft_output, 0);

        // Real FFT layout:
        // fft_output[0] = DC (real)
        // fft_output[1] = Nyquist (real)
        // fft_output[2..] = [Re(1), Im(1), Re(2), Im(2), ... , Re(N/2-1), Im(N/2-1)]
        // So we can compute magnitudes for bins k=1..127 (127 complex numbers).
        arm_cmplx_mag_f32(&fft_output[2], magnitude_spectrum, (FFT_SIZE/2 - 1)); // 127 mags

        const float freq_res = sample_rate / (float)FFT_SIZE; // ~0.203 Hz

        // --- 4) Noise floor from 0.5‚Äì2.0 Hz (avoid DC / ultra-low drift) ---
        // bins: k=ceil(0.5/freq_res) .. floor(2.0/freq_res)
        size_t k0 = (size_t)ceilf(0.5f / freq_res);
        size_t k1 = (size_t)floorf(2.0f / freq_res);
        if (k0 < 1) k0 = 1;
        if (k1 > (FFT_SIZE/2 - 1)) k1 = (FFT_SIZE/2 - 1); // max 127

        float noise_sum = 0.0f;
        size_t noise_cnt = 0;
        for (size_t k = k0; k <= k1; k++) {
            noise_sum += magnitude_spectrum[k - 1]; // k=1 maps to index 0
            noise_cnt++;
        }
        float noise_floor = (noise_cnt > 0) ? (noise_sum / (float)noise_cnt) : 0.25f;

        // Clamp noise floor so thresholds don't collapse
        if (noise_floor < 0.25f) noise_floor = 0.25f;

        // --- 5) Compute peaks in bands + dominance inside bands (not global) ---
        float tremor_peak = 0.0f;
        float tremor_freq = 0.0f;
        float dysk_peak   = 0.0f;
        float dysk_freq   = 0.0f;

        // Only search bins that matter (>=2.0 Hz) so walking sway doesn't "win"
        for (size_t k = 1; k <= (FFT_SIZE/2 - 1); k++) { // 1..127
            float f = k * freq_res;
            if (f < 2.0f) continue;  // Lowered from 2.5f to catch more tremor

            float mag = magnitude_spectrum[k - 1];

            if (f >= 3.0f && f <= 5.0f) {
                if (mag > tremor_peak) { tremor_peak = mag; tremor_freq = f; }
            } else if (f >= 5.0f && f <= 7.0f) {
                if (mag > dysk_peak)   { dysk_peak   = mag; dysk_freq   = f; }
            }
        }

        // --- 6) More sensitive adaptive thresholds ---
        // Make thresholds much more sensitive for testing
        const float tremor_threshold = noise_floor * 3.0f;   // Reduced from 10.0f
        const float dysk_threshold   = noise_floor * 4.0f;   // Reduced from 12.0f

        // --- 7) Decide condition using band dominance (more lenient for testing) ---
        const float DOM_RATIO = 1.1f;  // Reduced from 1.3f to be more sensitive

        bool tremor_detected = (tremor_peak > tremor_threshold) &&
                               (tremor_peak > dysk_peak * DOM_RATIO);

        bool dysk_detected   = (dysk_peak > dysk_threshold) &&
                               (dysk_peak > tremor_peak * DOM_RATIO);

        const char* condition = "NONE";
        float intensity_score = 0.0f; // normalized 0..something

        if (tremor_detected) {
            condition = "TREMOR";
            // intensity = how far above threshold (0 at threshold)
            intensity_score = (tremor_peak - tremor_threshold) / tremor_threshold;
        } else if (dysk_detected) {
            condition = "DYSK";
            intensity_score = (dysk_peak - dysk_threshold) / dysk_threshold;
        }

        // Convert to a raw intensity that your existing EMA + scaling can consume.
        // Keep it bounded-ish so you don't instantly saturate.
        if (intensity_score < 0.0f) intensity_score = 0.0f;
        if (intensity_score > 3.0f) intensity_score = 3.0f; // cap raw score

        // Return
        strncpy(raw_condition, condition, 15);
        raw_condition[15] = '\0';
        *raw_intensity = intensity_score; // now it's a normalized score, not arbitrary magnitude

        // Print with more debug info
        if (strcmp(condition, "TREMOR") == 0) {
            printf("Raw: üî¥ TREMOR | Score: %.2f | Peak@%.1fHz=%.2f | thr: %.2f ",
                   intensity_score, tremor_freq, tremor_peak, tremor_threshold);
        } else if (strcmp(condition, "DYSK") == 0) {
            printf("Raw: üü† DYSK | Score: %.2f | Peak@%.1fHz=%.2f | thr: %.2f ",
                   intensity_score, dysk_freq, dysk_peak, dysk_threshold);
        } else {
            printf("Raw: ‚úÖ Normal | T=%.2f/%.2f D=%.2f/%.2f noise=%.2f ",
                   tremor_peak, tremor_threshold, dysk_peak, dysk_threshold, noise_floor);
        }
    }

/**
 * @brief Process a complete 3-second data window
 * @note Called when 156 samples collected. Performs:
 *       - FFT analysis for tremor/dyskinesia detection
 *       - Multi-window confirmation logic
 *       - FOG state machine processing
 *       - BLE characteristic updates
 */
void process_window() {
        window_ready = false;  // Clear flag
        window_count++;
        
        // Calculate actual window timing to verify 3-second intervals
        uint32_t current_time = Kernel::get_ms_count();
        static uint32_t last_window_time = 0;
        float window_interval_sec = 0.0f;
        
        if (last_window_time > 0) {
            window_interval_sec = (current_time - last_window_time) / 1000.0f;
        }
        last_window_time = current_time;

    printf("\n>>> [3-SEC WINDOW #%-4lu] ", (unsigned long)window_count);
    if (window_interval_sec > 0.0f) {
        printf("(%.1fs interval) | ", window_interval_sec);
    }
    
    // Calculate statistics on the raw data
    float sum = 0.0f;
    for (size_t i = 0; i < WINDOW_SIZE; i++) {
        sum += accel_magnitude_buffer[i];
    }
    float mean = sum / WINDOW_SIZE;
    
    // Calculate variance (measure of movement)
    float variance = 0.0f;
    for (size_t i = 0; i < WINDOW_SIZE; i++) {
        float diff = accel_magnitude_buffer[i] - mean;
        variance += diff * diff;
    }
    variance /= WINDOW_SIZE;
    float std_dev = sqrtf(variance);
        
    // PHASE 3: Perform FFT analysis and detection (only if there's enough movement)
    char raw_detection[16] = "NONE";
    float raw_intensity = 0.0f;
    
    if (std_dev >= 0.005f) {  // Lowered from 0.05f to be more sensitive
        analyze_frequency_content(accel_magnitude_buffer, gyro_magnitude_buffer, WINDOW_SIZE, TARGET_SAMPLE_RATE_HZ, 
                                  raw_detection, &raw_intensity);
    } else {
        printf("Raw: ‚úÖ Normal (still, std=%.4f) ", std_dev);
        strcpy(raw_detection, "NONE");
        raw_intensity = 0.0f;
    }
    
    // Multi-window confirmation logic
    // Track consecutive detections for confirmation
    if (strcmp(raw_detection, "TREMOR") == 0) {
        detection_state.tremor_consecutive++;
        detection_state.dysk_consecutive = 0;
        detection_state.none_consecutive = 0;
        
        // Apply EMA smoothing to tremor intensity
        detection_state.tremor_ema_intensity = EMA_ALPHA * raw_intensity + 
                                             (1.0f - EMA_ALPHA) * detection_state.tremor_ema_intensity;
    } else if (strcmp(raw_detection, "DYSK") == 0) {
        detection_state.dysk_consecutive++;
        detection_state.tremor_consecutive = 0;
        detection_state.none_consecutive = 0;
        
        // Apply EMA smoothing to dyskinesia intensity
        detection_state.dysk_ema_intensity = EMA_ALPHA * raw_intensity + 
                                           (1.0f - EMA_ALPHA) * detection_state.dysk_ema_intensity;
    } else {  // "NONE"
        detection_state.none_consecutive++;
        detection_state.tremor_consecutive = 0;
        detection_state.dysk_consecutive = 0;
        // Keep EMA values but don't update them during "NONE" periods
    }
    
    // Determine confirmed intensities based on consecutive windows
    // Each condition gets its own intensity value (0 = not present)
    
    // Confirm tremor if detected in 2 consecutive windows (~6 sec)
    if (detection_state.tremor_consecutive >= DETECTION_CONFIRM_WINDOWS) {
        tremor_intensity = (uint16_t)(detection_state.tremor_ema_intensity * 500.0f);  // Scale to 0-1000
        if (tremor_intensity > 1000) tremor_intensity = 1000;
        dysk_intensity = 0;  // Clear other condition
    }
    // Confirm dyskinesia if detected in 2 consecutive windows (~6 sec)
    else if (detection_state.dysk_consecutive >= DETECTION_CONFIRM_WINDOWS) {
        dysk_intensity = (uint16_t)(detection_state.dysk_ema_intensity * 500.0f);  // Scale to 0-1000
        if (dysk_intensity > 1000) dysk_intensity = 1000;
        tremor_intensity = 0;  // Clear other condition
    }
    // Clear to NONE only after 3 consecutive windows (~9 sec)
    else if (detection_state.none_consecutive >= CLEAR_CONFIRM_WINDOWS) {
        tremor_intensity = 0;
        dysk_intensity = 0;
        detection_state.tremor_ema_intensity = 0.0f;  // Reset EMA when cleared
        detection_state.dysk_ema_intensity = 0.0f;
    }
    // Otherwise, keep previous state (no change)
    
    // Display confirmed result
    printf("‚Üí Confirmed: ");
    if (tremor_intensity > 0) {
        printf("üî¥ TREMOR [%u/%u] | Intensity: %u\n", 
               detection_state.tremor_consecutive, DETECTION_CONFIRM_WINDOWS, tremor_intensity);
    } else if (dysk_intensity > 0) {
        printf("üü† DYSK [%u/%u] | Intensity: %u\n", 
               detection_state.dysk_consecutive, DETECTION_CONFIRM_WINDOWS, dysk_intensity);
    } else {
        printf("‚úÖ NONE [%u/%u]\n", detection_state.none_consecutive, CLEAR_CONFIRM_WINDOWS);
    }
        
        // =========================================================================
        // PHASE 4: FOG (Freezing of Gait) Detection
        // =========================================================================
        
    // Calculate cadence (steps per minute)
    float window_duration_sec = WINDOW_SIZE / TARGET_SAMPLE_RATE_HZ;  // 3.0 seconds
    float cadence = (steps_in_window / window_duration_sec) * 60.0f;  // steps/min
        
        // Define thresholds (more sensitive for realistic FOG detection)
        const float WALKING_CADENCE_MIN = 20.0f;     // Reduced from 30.0f - easier to detect walking
        const float WALKING_CADENCE_MAX = 180.0f;    // Maximum realistic walking
        const float FREEZE_CADENCE_MAX = 10.0f;      // Reduced from 15.0f - more sensitive freeze detection
        const float WALKING_VARIANCE_MIN = 0.02f;    // Reduced from 0.04f - easier to detect movement
        const float FREEZE_VARIANCE_MAX = 0.015f;    // Reduced from 0.03f - more sensitive stillness
        const uint32_t MIN_WALKING_DURATION_MS = 2000;  // Reduced from 3000ms - shorter walking requirement
        const uint32_t FREEZE_CONFIRMATION_MS = 1500;   // Reduced from 2000ms - faster freeze confirmation
        
        // Reuse the current_time variable from earlier in the function
        bool currently_walking = (cadence >= WALKING_CADENCE_MIN && 
                                cadence <= WALKING_CADENCE_MAX &&
                                variance >= WALKING_VARIANCE_MIN);
        
    bool freeze_indicators = (cadence < FREEZE_CADENCE_MAX && 
                             variance < FREEZE_VARIANCE_MAX);
    
    // DEBUG: Add FOG detection info
    printf("FOG: steps=%u cad=%.1f var=%.4f walk=%s freeze=%s | ", 
           steps_in_window, cadence, variance, 
           currently_walking ? "YES" : "NO", 
           freeze_indicators ? "YES" : "NO");
        
    // Safety check: Can't be in freeze states if never walked
    if ((fog_detector.state == FOG_POTENTIAL_FREEZE || fog_detector.state == FOG_FREEZE_CONFIRMED) &&
        fog_detector.walking_start_time == 0) {
        // Invalid state - reset to NOT_WALKING
        printf("   ‚ö†Ô∏è  WARNING: Invalid FOG state detected, resetting\n");
        fog_detector.state = FOG_NOT_WALKING;
        fog_detector.consecutive_walking_windows = 0;
        fog_detector.consecutive_freeze_windows = 0;
    }
    
    // State machine
    switch (fog_detector.state) {
        case FOG_NOT_WALKING: {
            if (currently_walking) {
                fog_detector.consecutive_walking_windows++;
                
                if (fog_detector.consecutive_walking_windows >= 2) {
                    fog_detector.state = FOG_WALKING;
                    fog_detector.walking_start_time = current_time;
                    fog_detector.consecutive_freeze_windows = 0;
                    printf("üö∂ Walking started | ");
        }
    } else {
                fog_detector.consecutive_walking_windows = 0;
            }
            break;
        }
            
        case FOG_WALKING: {
            uint32_t walking_duration = current_time - fog_detector.walking_start_time;
            
            if (currently_walking) {
                // Continue walking
            } else if (freeze_indicators) {
                if (walking_duration >= MIN_WALKING_DURATION_MS) {
                    fog_detector.state = FOG_POTENTIAL_FREEZE;
                    fog_detector.freeze_start_time = current_time;
                    fog_detector.consecutive_freeze_windows = 1;
                    printf("‚ö†Ô∏è Freeze? | ");
                } else {
                    fog_detector.state = FOG_NOT_WALKING;
                    fog_detector.consecutive_walking_windows = 0;
                }
            } else {
                fog_detector.state = FOG_NOT_WALKING;
                fog_detector.consecutive_walking_windows = 0;
            }
            break;
        }
            
        case FOG_POTENTIAL_FREEZE: {
            uint32_t freeze_duration = current_time - fog_detector.freeze_start_time;
            
            if (currently_walking) {
                fog_detector.state = FOG_WALKING;
                fog_detector.consecutive_freeze_windows = 0;
                printf("Resumed | ");
            } else if (freeze_indicators) {
                fog_detector.consecutive_freeze_windows++;
                
                if (freeze_duration >= FREEZE_CONFIRMATION_MS) {
                    fog_detector.state = FOG_FREEZE_CONFIRMED;
                    printf("‚ùÑÔ∏è FOG! | ");
                }
            } else {
                fog_detector.state = FOG_NOT_WALKING;
                fog_detector.consecutive_walking_windows = 0;
                fog_detector.consecutive_freeze_windows = 0;
            }
            break;
        }
            
        case FOG_FREEZE_CONFIRMED: {
            printf("‚ùÑÔ∏è FOG CONFIRMED | ");
            
            if (currently_walking) {
                fog_detector.state = FOG_WALKING;
                fog_detector.consecutive_freeze_windows = 0;
                printf("Recovered | ");
            }
            break;
        }
    }
    
    fog_detector.previous_cadence = cadence;
        
    // Reset step counter for next window
    steps_in_window = 0;
    
    // PHASE 5: Update FOG status for BLE (0 = NOFOG, 1 = FOG)
    if (fog_detector.state == FOG_FREEZE_CONFIRMED) {
        fog_status = 1;  // FOG detected
    } else {
        fog_status = 0;  // No FOG
    }
    
    // BLE update with explicit data format documentation
    if (ble_connected) {
        printf("üì° BLE TX: Tremor=%u/1000, Dysk=%u/1000, FOG=%s ‚úì\n", 
               tremor_intensity, dysk_intensity, (fog_status == 1) ? "ALARM" : "OK");
        update_ble_characteristics();
    } else {
        printf("üì° BLE: Not connected (advertising...)\n");
    }
    
    printf("üîπ LED Pattern: ");
    if (fog_status == 1) printf("FOG ALARM (fast triple-blink)\n");
    else if (tremor_intensity > 0) printf("TREMOR (~2Hz, %u%% duty)\n", 20 + (tremor_intensity * 60) / 1000);
    else if (dysk_intensity > 0) printf("DYSK (~4Hz, %u%% duty)\n", 20 + (dysk_intensity * 60) / 1000);
    else printf("Heartbeat (system alive)\n");
}

// =============================================================================
// Bluetooth Low Energy (BLE) Communication Functions
// =============================================================================

/**
 * @brief Schedule BLE event processing on event queue
 */
void schedule_ble_events(BLE::OnEventsToProcessCallbackContext *context) {
    ble_event_queue.call(Callback<void()>(&context->ble, &BLE::processEvents));
}

/**
 * @brief BLE initialization completion callback
 * @param params BLE initialization context with error status
 * @note Sets up GATT service, characteristics, and advertising
 */
void on_ble_init_complete(BLE::InitializationCompleteCallbackContext *params) {
    if (params->error != BLE_ERROR_NONE) {
        printf("‚ùå BLE initialization failed\n");
        return;
    }
    
    printf("‚úì BLE initialized successfully\n");

    BLE &ble = params->ble;
    gatt_server = &ble.gattServer();
    
    // Create characteristics with notify capability
    // Three characteristics for three conditions (Tremor, Dyskinesia, FOG)
    tremor_char = new GattCharacteristic(
        TREMOR_CHAR_UUID,
        (uint8_t*)&tremor_intensity,
        sizeof(tremor_intensity),
        sizeof(tremor_intensity),
        GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY
    );
    
    dysk_char = new GattCharacteristic(
        DYSK_CHAR_UUID,
        (uint8_t*)&dysk_intensity,
        sizeof(dysk_intensity),
        sizeof(dysk_intensity),
        GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY
    );
    
    fog_char = new GattCharacteristic(
        FOG_CHAR_UUID,
        (uint8_t*)&fog_status,
        sizeof(fog_status),
        sizeof(fog_status),
        GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_READ | GattCharacteristic::BLE_GATT_CHAR_PROPERTIES_NOTIFY
    );
    
    // Create service with characteristics
    GattCharacteristic *char_table[] = {tremor_char, dysk_char, fog_char};
    GattService pd_service(PD_SERVICE_UUID, char_table, 3);
    
    // Add service to GATT server
    gatt_server->addService(pd_service);
    
    // Setup advertising
    ble::AdvertisingParameters adv_params(
        ble::advertising_type_t::CONNECTABLE_UNDIRECTED,
        ble::adv_interval_t(ble::millisecond_t(1000))
    );
    
    ble.gap().setAdvertisingParameters(ble::LEGACY_ADVERTISING_HANDLE, adv_params);
    
    // Build advertising data
    uint8_t adv_buffer[ble::LEGACY_ADVERTISING_MAX_SIZE];
    ble::AdvertisingDataBuilder adv_data_builder(adv_buffer);
    
    adv_data_builder.setFlags();
    adv_data_builder.setName("PD_Detector");
    
    // Note: Service UUID in advertising would be nice for UX but not supported in this mbed version
    
    // Set advertising payload
    ble_error_t error = ble.gap().setAdvertisingPayload(
        ble::LEGACY_ADVERTISING_HANDLE,
        adv_data_builder.getAdvertisingData()
    );
    
    if (error != BLE_ERROR_NONE) {
        printf("‚ùå Failed to set advertising payload\n");
        return;
    }
    
    // Start advertising
    error = ble.gap().startAdvertising(ble::LEGACY_ADVERTISING_HANDLE);
    
    if (error != BLE_ERROR_NONE) {
        printf("‚ùå Failed to start advertising\n");
        return;
    }

    printf("‚úì BLE advertising started\n");
    printf("‚úì Device name: \"PD_Detector\"\n");
    printf("‚úì Ready to connect from phone!\n\n");
}

class PDGapEventHandler : public ble::Gap::EventHandler {
    void onConnectionComplete(const ble::ConnectionCompleteEvent &event) override {
        if (event.getStatus() == BLE_ERROR_NONE) {
            ble_connected = true;
            printf("\nüì± BLE Device Connected!\n\n");
        }
    }
    
    void onDisconnectionComplete(const ble::DisconnectionCompleteEvent &event) override {
        ble_connected = false;
        printf("\nüì± BLE Device Disconnected\n\n");
        
        // Restart advertising
        ble_instance.gap().startAdvertising(ble::LEGACY_ADVERTISING_HANDLE);
        printf("‚úì Advertising restarted\n\n");
    }
};

static PDGapEventHandler gap_event_handler;

/**
 * @brief Update BLE characteristics and send notifications on changes
 * @note Compares current values with previous values and sends notifications
 *       for tremor intensity, dyskinesia intensity, and FOG status
 */
void update_ble_characteristics() {
    if (!ble_connected || gatt_server == nullptr) return;

    bool tremor_changed = (tremor_intensity != previous_tremor);
    bool dysk_changed = (dysk_intensity != previous_dysk);
    bool fog_changed = (fog_status != previous_fog);

    if (tremor_changed) {
        gatt_server->write(
            tremor_char->getValueHandle(),
            (uint8_t*)&tremor_intensity,
            sizeof(tremor_intensity)
        );

        if (tremor_intensity > 0) {
            printf("   üì¢ BLE NOTIFICATION: TREMOR intensity = %u\n", tremor_intensity);
        } else {
            printf("   üì¢ BLE NOTIFICATION: TREMOR cleared\n");
        }

        previous_tremor = tremor_intensity;
    }

    if (dysk_changed) {
        gatt_server->write(
            dysk_char->getValueHandle(),
            (uint8_t*)&dysk_intensity,
            sizeof(dysk_intensity)
        );

        if (dysk_intensity > 0) {
            printf("   üì¢ BLE NOTIFICATION: DYSK intensity = %u\n", dysk_intensity);
        } else {
            printf("   üì¢ BLE NOTIFICATION: DYSK cleared\n");
        }

        previous_dysk = dysk_intensity;
    }

    if (fog_changed) {
        gatt_server->write(
            fog_char->getValueHandle(),
            (uint8_t*)&fog_status,
            sizeof(fog_status)
        );

        if (fog_status == 1) {
            printf("   üì¢ BLE NOTIFICATION: FOG detected!\n");
        } else {
            printf("   üì¢ BLE NOTIFICATION: FOG cleared\n");
        }

        previous_fog = fog_status;
    }

    if (tremor_changed || dysk_changed || fog_changed) {
        printf("   BLE characteristics updated and notifications sent!\n");
    }
}

// =============================================================================
// Main Application Entry Point
// =============================================================================

/**
 * @brief Main application function
 * @return int Program exit code (never returns in embedded context)
 * 
 * @note Initializes hardware, sensors, BLE, and runs main detection loop:
 *       1. Hardware setup (I2C, interrupts, BLE)
 *       2. Sensor configuration and validation
 *       3. Main loop: data acquisition, processing, and transmission
 */
int main() {
        // Startup banner
        printf("\n\n");
        printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïë   PARKINSON'S DISEASE MOVEMENT DETECTOR                       ‚ïë\n");
        printf("‚ïë   Phases 1-4: Full Detection System                          ‚ïë\n");
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïë   Board: STM32 DISCO-L475VG-IOT01A                            ‚ïë\n");
        printf("‚ïë   Sensor: LSM6DSL (Accel + Gyro)                              ‚ïë\n");
        printf("‚ïë   Sample Rate: %.0f Hz | Window: 3 sec | FFT: %zu points       ‚ïë\n", 
            TARGET_SAMPLE_RATE_HZ, FFT_SIZE);
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïë   Detection Capabilities:                                     ‚ïë\n");
        printf("‚ïë   üî¥ Tremor: 3-5 Hz rhythmic oscillations                     ‚ïë\n");
        printf("‚ïë   üü† Dyskinesia: 5-7 Hz dance-like movements                  ‚ïë\n");
        printf("‚ïë   ‚ùÑÔ∏è  FOG: Freezing after walking (step detection)            ‚ïë\n");
        printf("‚ïë                                                               ‚ïë\n");
        printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    printf("\n");

        // Configure I2C frequency (400kHz = fast mode)
    i2c.frequency(400000);
        printf("I2C configured at 400kHz\n\n");

        // Initialize sensor
        if (!init_lsm6dsl()) {
        printf("\n");
            printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
            printf("‚ïë                    ‚ùå INITIALIZATION FAILED ‚ùå                 ‚ïë\n");
            printf("‚ïë                                                               ‚ïë\n");
            printf("‚ïë  Check:                                                       ‚ïë\n");
            printf("‚ïë  1. Sensor connections (I2C: PB_11=SDA, PB_10=SCL)            ‚ïë\n");
            printf("‚ïë  2. Power supply                                              ‚ïë\n");
            printf("‚ïë  3. I2C address (0x6A)                                        ‚ïë\n");
            printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
            
            // Blink LED rapidly to indicate error
        while (true) { 
                led = !led;
                ThisThread::sleep_for(200ms);
        }
    }

    // Attach interrupt handler
    data_ready_pin.rise(&data_ready_isr);
    printf("‚úì Interrupt handler attached to INT1 pin\n\n");

    // Initialize BLE
    printf("Initializing BLE...\n");
    ble_instance.onEventsToProcess(schedule_ble_events);
    ble_instance.gap().setEventHandler(&gap_event_handler);
    ble_instance.init(on_ble_init_complete);
    
    // Wait a bit for BLE to initialize
    ThisThread::sleep_for(500ms);
        
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                üöÄ STARTING DETECTION SYSTEM üöÄ                ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  ACTIVE FEATURES:                                             ‚ïë\n");
    printf("‚ïë  ‚úì 52 Hz interrupt-driven sampling                            ‚ïë\n");
    printf("‚ïë  ‚úì 3-second windowed data collection                          ‚ïë\n");
    printf("‚ïë  ‚úì FFT-based frequency analysis                               ‚ïë\n");
    printf("‚ïë  ‚úì Tremor detection (3-5 Hz)                                  ‚ïë\n");
    printf("‚ïë  ‚úì Dyskinesia detection (5-7 Hz)                              ‚ïë\n");
    printf("‚ïë  ‚úì FOG detection (step tracking + gait analysis)              ‚ïë\n");
    printf("‚ïë  ‚úì BLE data transmission (Phase 5)                            ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  BLE ADVERTISING:                                             ‚ïë\n");
    printf("‚ïë  Device Name: \"PD_Detector\"                                 ‚ïë\n");
    printf("‚ïë  (Note: Full BLE transmission available via app)              ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  LED VISUAL INDICATION:                                       ‚ïë\n");
    printf("‚ïë  üî¥ Tremor: Blink ~2Hz (duty cycle ‚àù intensity)               ‚ïë\n");
    printf("‚ïë  üü† Dyskinesia: Blink ~4Hz (duty cycle ‚àù intensity)           ‚ïë\n");
    printf("‚ïë  ‚ùÑÔ∏è  FOG: Fast triple-blink alarm pattern                     ‚ïë\n");
    printf("‚ïë  üíö None: Slow heartbeat (system alive)                       ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  BLE DATA FORMAT (3 characteristics):                         ‚ïë\n");
    printf("‚ïë  üìä Tremor Intensity: 0-1000 scale                            ‚ïë\n");
    printf("‚ïë  üìä Dyskinesia Intensity: 0-1000 scale                        ‚ïë\n");
    printf("‚ïë  üìä FOG Status: 0=NO_FOG, 1=FOG_DETECTED                      ‚ïë\n");
    printf("‚ïë                                                               ‚ïë\n");
    printf("‚ïë  TEST SCENARIOS (watch LED patterns):                         ‚ïë\n");
    printf("‚ïë  üî¥ Shake slowly (4 Hz) ‚Üí Tremor                              ‚ïë\n");
    printf("‚ïë  üü† Shake fast (6 Hz) ‚Üí Dyskinesia                            ‚ïë\n");
    printf("‚ïë  ‚ùÑÔ∏è  Walk in place, then stop ‚Üí FOG                           ‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
        
        uint32_t last_diagnostic_time = 0;
        uint32_t last_poll_time = 0;
        uint32_t last_interrupt_time = Kernel::get_ms_count();  // Initialize to current time
        
        // Main loop
    while (true) {
        uint32_t now = Kernel::get_ms_count();
        
        // Update LED indication patterns continuously
        update_led_indication();
            
        // Diagnostic output every 10 seconds (reduced frequency)
        if (now - last_diagnostic_time >= 10000) {
            printf("\nüíö System Health: %lu interrupts | %lu samples | %lu windows processed\n", 
                interrupt_count, sample_count, (unsigned long)window_count);
            float avg_window_rate = (window_count > 0) ? (now / 1000.0f) / window_count : 0.0f;
            printf("   üìä Window rate: %.1f sec/window (target: 3.0 sec)\n", avg_window_rate);
            last_diagnostic_time = now;
        }
            
            // Method 1: Process ALL pending samples (prevents sample loss)
            if (new_data_available) {
                // Process all pending samples to prevent accumulation
                while (pending_samples > 0) {
                    new_data_available = false;
                    last_interrupt_time = now;
                    read_sensor_data();
                    
                    // Atomically decrement pending count
                    __disable_irq();
                    if (pending_samples > 0) pending_samples--;
                    __enable_irq();
                    
                    // Check if more samples arrived during processing
                    if (pending_samples == 0) {
                        new_data_available = false;
                        break;
                    }
                }
            }
            // Method 2: Polling fallback - only if no interrupts for >100ms
            // This prevents oversample jitter from aggressive polling
            else if ((now - last_interrupt_time > 100) && (now - last_poll_time >= 19)) {
                last_poll_time = now;
                
                // Check if data is actually ready
                uint8_t status = 0;
                if (read_register(STATUS_REG, status)) {
                    // Bit 0 = XLDA (accel data available)
                    // Bit 1 = GDA (gyro data available)
                    bool accel_ready = (status & 0x01) != 0;
                    bool gyro_ready = (status & 0x02) != 0;
                    
                    if (accel_ready && gyro_ready) {
                        // Data is available but interrupt didn't fire!
                        // Read it anyway using polling mode
                        read_sensor_data();
                    }
                }
            }
            
        // PHASE 2: Check if a complete window is ready for processing
        if (window_ready) {
            process_window();
        }
        
        // Process BLE events
        ble_event_queue.dispatch_once();
        
        // Small delay to prevent busy-waiting h
        ThisThread::sleep_for(1ms);
    }
}


